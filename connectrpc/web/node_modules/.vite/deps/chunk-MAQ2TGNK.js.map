{
  "version": 3,
  "sources": ["../../@connectrpc/connect/dist/esm/code.js", "../../@connectrpc/connect/dist/esm/protocol-connect/code-string.js", "../../@connectrpc/connect/dist/esm/connect-error.js", "../../@connectrpc/connect/dist/esm/http-headers.js", "../../@connectrpc/connect/dist/esm/any-client.js", "../../@connectrpc/connect/dist/esm/protocol/compression.js", "../../@connectrpc/connect/dist/esm/protocol/envelope.js", "../../@connectrpc/connect/dist/esm/protocol/limit-io.js", "../../@connectrpc/connect/dist/esm/protocol/async-iterable.js", "../../@connectrpc/connect/dist/esm/callback-client.js", "../../@connectrpc/connect/dist/esm/promise-client.js", "../../@connectrpc/connect/dist/esm/protocol/signals.js", "../../@connectrpc/connect/dist/esm/context-values.js", "../../@connectrpc/connect/dist/esm/implementation.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/trailer.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/headers.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/headers.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/content-type.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/parse-timeout.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/gen/status_pb.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/trailer-status.js", "../../@connectrpc/connect/dist/esm/protocol/content-type-matcher.js", "../../@connectrpc/connect/dist/esm/protocol/create-method-url.js", "../../@connectrpc/connect/dist/esm/protocol/normalize.js", "../../@connectrpc/connect/dist/esm/interceptor.js", "../../@connectrpc/connect/dist/esm/protocol/invoke-implementation.js", "../../@connectrpc/connect/dist/esm/protocol/serialization.js", "../../@connectrpc/connect/dist/esm/protocol/universal.js", "../../@connectrpc/connect/dist/esm/protocol/universal-handler.js", "../../@connectrpc/connect/dist/esm/protocol-grpc-web/handler-factory.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/content-type.js", "../../@connectrpc/connect/dist/esm/protocol-grpc/handler-factory.js", "../../@connectrpc/connect/dist/esm/protocol-connect/content-type.js", "../../@connectrpc/connect/dist/esm/protocol-connect/error-json.js", "../../@connectrpc/connect/dist/esm/protocol-connect/end-stream.js", "../../@connectrpc/connect/dist/esm/protocol-connect/headers.js", "../../@connectrpc/connect/dist/esm/protocol-connect/http-status.js", "../../@connectrpc/connect/dist/esm/protocol-connect/parse-timeout.js", "../../@connectrpc/connect/dist/esm/protocol-connect/query-params.js", "../../@connectrpc/connect/dist/esm/protocol-connect/trailer-mux.js", "../../@connectrpc/connect/dist/esm/protocol-connect/version.js", "../../@connectrpc/connect/dist/esm/protocol-connect/handler-factory.js", "../../@connectrpc/connect/dist/esm/router.js", "../../@connectrpc/connect/dist/esm/cors.js", "../../@connectrpc/connect/dist/esm/protocol-connect/request-header.js", "../../@connectrpc/connect/dist/esm/protocol-connect/validate-response.js", "../../@connectrpc/connect/dist/esm/protocol-connect/get-request.js", "../../@connectrpc/connect/dist/esm/protocol/run-call.js", "../../@connectrpc/connect/dist/esm/protocol-connect/transport.js", "../../@connectrpc/connect/dist/esm/protocol/universal-handler-client.js", "../../@connectrpc/connect/dist/esm/router-transport.js"],
  "sourcesContent": ["// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Connect represents categories of errors as codes, and each code maps to a\n * specific HTTP status code. The codes and their semantics were chosen to\n * match gRPC. Only the codes below are valid â€” there are no user-defined\n * codes.\n *\n * See the specification at https://connectrpc.com/docs/protocol#error-codes\n * for details.\n */\nexport var Code;\n(function (Code) {\n    /**\n     * Canceled, usually be the user\n     */\n    Code[Code[\"Canceled\"] = 1] = \"Canceled\";\n    /**\n     * Unknown error\n     */\n    Code[Code[\"Unknown\"] = 2] = \"Unknown\";\n    /**\n     * Argument invalid regardless of system state\n     */\n    Code[Code[\"InvalidArgument\"] = 3] = \"InvalidArgument\";\n    /**\n     * Operation expired, may or may not have completed.\n     */\n    Code[Code[\"DeadlineExceeded\"] = 4] = \"DeadlineExceeded\";\n    /**\n     * Entity not found.\n     */\n    Code[Code[\"NotFound\"] = 5] = \"NotFound\";\n    /**\n     * Entity already exists.\n     */\n    Code[Code[\"AlreadyExists\"] = 6] = \"AlreadyExists\";\n    /**\n     * Operation not authorized.\n     */\n    Code[Code[\"PermissionDenied\"] = 7] = \"PermissionDenied\";\n    /**\n     * Quota exhausted.\n     */\n    Code[Code[\"ResourceExhausted\"] = 8] = \"ResourceExhausted\";\n    /**\n     * Argument invalid in current system state.\n     */\n    Code[Code[\"FailedPrecondition\"] = 9] = \"FailedPrecondition\";\n    /**\n     * Operation aborted.\n     */\n    Code[Code[\"Aborted\"] = 10] = \"Aborted\";\n    /**\n     * Out of bounds, use instead of FailedPrecondition.\n     */\n    Code[Code[\"OutOfRange\"] = 11] = \"OutOfRange\";\n    /**\n     * Operation not implemented or disabled.\n     */\n    Code[Code[\"Unimplemented\"] = 12] = \"Unimplemented\";\n    /**\n     * Internal error, reserved for \"serious errors\".\n     */\n    Code[Code[\"Internal\"] = 13] = \"Internal\";\n    /**\n     * Unavailable, client should back off and retry.\n     */\n    Code[Code[\"Unavailable\"] = 14] = \"Unavailable\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */\n    Code[Code[\"DataLoss\"] = 15] = \"DataLoss\";\n    /**\n     * Request isn't authenticated.\n     */\n    Code[Code[\"Unauthenticated\"] = 16] = \"Unauthenticated\";\n})(Code || (Code = {}));\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\n/**\n * codeToString returns the string representation of a Code.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeToString(value) {\n    const name = Code[value];\n    if (typeof name != \"string\") {\n        return value.toString();\n    }\n    return (name[0].toLowerCase() +\n        name.substring(1).replace(/[A-Z]/g, (c) => \"_\" + c.toLowerCase()));\n}\nlet stringToCode;\n/**\n * codeFromString parses the string representation of a Code in snake_case.\n * For example, the string \"permission_denied\" parses into Code.PermissionDenied.\n *\n * If the given string cannot be parsed, the function returns undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeFromString(value) {\n    if (!stringToCode) {\n        stringToCode = {};\n        for (const value of Object.values(Code)) {\n            if (typeof value == \"string\") {\n                continue;\n            }\n            stringToCode[codeToString(value)] = value;\n        }\n    }\n    return stringToCode[value];\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"./code.js\";\nimport { codeToString } from \"./protocol-connect/code-string.js\";\n/**\n * ConnectError captures four pieces of information: a Code, an error\n * message, an optional cause of the error, and an optional collection of\n * arbitrary Protobuf messages called  \"details\".\n *\n * Because developer tools typically show just the error message, we prefix\n * it with the status code, so that the most important information is always\n * visible immediately.\n *\n * Error details are wrapped with google.protobuf.Any on the wire, so that\n * a server or middleware can attach arbitrary data to an error. Use the\n * method findDetails() to retrieve the details.\n */\nexport class ConnectError extends Error {\n    /**\n     * Create a new ConnectError.\n     * If no code is provided, code \"unknown\" is used.\n     * Outgoing details are only relevant for the server side - a service may\n     * raise an error with details, and it is up to the protocol implementation\n     * to encode and send the details along with error.\n     */\n    constructor(message, code = Code.Unknown, metadata, outgoingDetails, cause) {\n        super(createMessage(message, code));\n        this.name = \"ConnectError\";\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.rawMessage = message;\n        this.code = code;\n        this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});\n        this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];\n        this.cause = cause;\n    }\n    /**\n     * Convert any value - typically a caught error into a ConnectError,\n     * following these rules:\n     * - If the value is already a ConnectError, return it as is.\n     * - If the value is an AbortError from the fetch API, return the message\n     *   of the AbortError with code Canceled.\n     * - For other Errors, return the error message with code Unknown by default.\n     * - For other values, return the values String representation as a message,\n     *   with the code Unknown by default.\n     * The original value will be used for the \"cause\" property for the new\n     * ConnectError.\n     */\n    static from(reason, code = Code.Unknown) {\n        if (reason instanceof ConnectError) {\n            return reason;\n        }\n        if (reason instanceof Error) {\n            if (reason.name == \"AbortError\") {\n                // Fetch requests can only be canceled with an AbortController.\n                // We detect that condition by looking at the name of the raised\n                // error object, and translate to the appropriate status code.\n                return new ConnectError(reason.message, Code.Canceled);\n            }\n            return new ConnectError(reason.message, code, undefined, undefined, reason);\n        }\n        return new ConnectError(String(reason), code, undefined, undefined, reason);\n    }\n    static [Symbol.hasInstance](v) {\n        if (!(v instanceof Error)) {\n            return false;\n        }\n        if (Object.getPrototypeOf(v) === ConnectError.prototype) {\n            return true;\n        }\n        return (v.name === \"ConnectError\" &&\n            \"code\" in v &&\n            typeof v.code === \"number\" &&\n            \"metadata\" in v &&\n            \"details\" in v &&\n            Array.isArray(v.details) &&\n            \"rawMessage\" in v &&\n            typeof v.rawMessage == \"string\" &&\n            \"cause\" in v);\n    }\n    findDetails(typeOrRegistry) {\n        const registry = \"typeName\" in typeOrRegistry\n            ? {\n                findMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : undefined,\n            }\n            : typeOrRegistry;\n        const details = [];\n        for (const data of this.details) {\n            if (\"getType\" in data) {\n                if (registry.findMessage(data.getType().typeName)) {\n                    details.push(data);\n                }\n                continue;\n            }\n            const type = registry.findMessage(data.type);\n            if (type) {\n                try {\n                    details.push(type.fromBinary(data.value));\n                }\n                catch (_) {\n                    // We silently give up if we are unable to parse the detail, because\n                    // that appears to be the least worst behavior.\n                    // It is very unlikely that a user surrounds a catch body handling the\n                    // error with another try-catch statement, and we do not want to\n                    // recommend doing so.\n                }\n            }\n        }\n        return details;\n    }\n}\n/**\n * Create an error message, prefixing the given code.\n */\nfunction createMessage(message, code) {\n    return message.length\n        ? `[${codeToString(code)}] ${message}`\n        : `[${codeToString(code)}]`;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { protoBase64 } from \"@bufbuild/protobuf\";\nimport { ConnectError } from \"./connect-error.js\";\nimport { Code } from \"./code.js\";\n/**\n * Encode a single binary header value according to the Connect\n * and gRPC specifications.\n *\n * This function accepts raw binary data from a buffer, a string\n * with UTF-8 text, or a protobuf message. It encodes the input\n * with unpadded base64 and returns a string that can be used for\n * a header whose name ends with `-bin`.\n */\nexport function encodeBinaryHeader(value) {\n    let bytes;\n    if (typeof value == \"object\" && \"getType\" in value) {\n        bytes = value.toBinary();\n    }\n    else if (typeof value == \"string\") {\n        bytes = new TextEncoder().encode(value);\n    }\n    else {\n        bytes = value instanceof Uint8Array ? value : new Uint8Array(value);\n    }\n    return protoBase64.enc(bytes).replace(/=+$/, \"\");\n}\nexport function decodeBinaryHeader(value, type, options) {\n    try {\n        const bytes = protoBase64.dec(value);\n        if (type) {\n            return type.fromBinary(bytes, options);\n        }\n        return bytes;\n    }\n    catch (e) {\n        throw ConnectError.from(e, Code.DataLoss);\n    }\n}\n/**\n * Merge two or more Headers objects by appending all fields from\n * all inputs to a new Headers object.\n */\nexport function appendHeaders(...headers) {\n    const h = new Headers();\n    for (const e of headers) {\n        e.forEach((value, key) => {\n            h.append(key, value);\n        });\n    }\n    return h;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create any client for the given service.\n *\n * The given createMethod function is called for each method definition\n * of the service. The function it returns is added to the client object\n * as a method.\n */\nexport function makeAnyClient(service, createMethod) {\n    const client = {};\n    for (const [localName, methodInfo] of Object.entries(service.methods)) {\n        const method = createMethod(Object.assign(Object.assign({}, methodInfo), { localName,\n            service }));\n        if (method != null) {\n            client[localName] = method;\n        }\n    }\n    return client;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * compressedFlag indicates that the data in a EnvelopedMessage is\n * compressed. It has the same meaning in the gRPC-Web, gRPC-HTTP2,\n * and Connect protocols.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const compressedFlag = 0b00000001;\n/**\n * Validates the request encoding and determines the accepted response encoding.\n *\n * Returns the request and response compression to use. If the client requested\n * an encoding that is not available, the returned object contains an error that\n * must be used for the response.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function compressionNegotiate(available, requested, // e.g. the value of the Grpc-Encoding header\naccepted, // e.g. the value of the Grpc-Accept-Encoding header\nheaderNameAcceptEncoding) {\n    let request = null;\n    let response = null;\n    let error = undefined;\n    if (requested !== null && requested !== \"identity\") {\n        const found = available.find((c) => c.name === requested);\n        if (found) {\n            request = found;\n        }\n        else {\n            // To comply with https://github.com/grpc/grpc/blob/master/doc/compression.md\n            // and the Connect protocol, we return code \"unimplemented\" and specify\n            // acceptable compression(s).\n            const acceptable = available.map((c) => c.name).join(\",\");\n            error = new ConnectError(`unknown compression \"${requested}\": supported encodings are ${acceptable}`, Code.Unimplemented, {\n                [headerNameAcceptEncoding]: acceptable,\n            });\n        }\n    }\n    if (accepted === null || accepted === \"\") {\n        // Support asymmetric compression. This logic follows\n        // https://github.com/grpc/grpc/blob/master/doc/compression.md and common\n        // sense.\n        response = request;\n    }\n    else {\n        const acceptNames = accepted.split(\",\").map((n) => n.trim());\n        for (const name of acceptNames) {\n            const found = available.find((c) => c.name === name);\n            if (found) {\n                response = found;\n                break;\n            }\n        }\n    }\n    return { request, response, error };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { compressedFlag } from \"./compression.js\";\n/**\n * Create a WHATWG ReadableStream of enveloped messages from a ReadableStream\n * of bytes.\n *\n * Ideally, this would simply be a TransformStream, but ReadableStream.pipeThrough\n * does not have the necessary availability at this time.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createEnvelopeReadableStream(stream) {\n    let reader;\n    let buffer = new Uint8Array(0);\n    function append(chunk) {\n        const n = new Uint8Array(buffer.length + chunk.length);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        buffer = n;\n    }\n    return new ReadableStream({\n        start() {\n            reader = stream.getReader();\n        },\n        async pull(controller) {\n            let header = undefined;\n            for (;;) {\n                if (header === undefined && buffer.byteLength >= 5) {\n                    let length = 0;\n                    for (let i = 1; i < 5; i++) {\n                        length = (length << 8) + buffer[i];\n                    }\n                    header = { flags: buffer[0], length };\n                }\n                if (header !== undefined && buffer.byteLength >= header.length + 5) {\n                    break;\n                }\n                const result = await reader.read();\n                if (result.done) {\n                    break;\n                }\n                append(result.value);\n            }\n            if (header === undefined) {\n                if (buffer.byteLength == 0) {\n                    controller.close();\n                    return;\n                }\n                controller.error(new ConnectError(\"premature end of stream\", Code.DataLoss));\n                return;\n            }\n            const data = buffer.subarray(5, 5 + header.length);\n            buffer = buffer.subarray(5 + header.length);\n            controller.enqueue({\n                flags: header.flags,\n                data,\n            });\n        },\n    });\n}\n/**\n * Compress an EnvelopedMessage.\n *\n * Raises Internal if an enveloped message is already compressed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport async function envelopeCompress(envelope, compression, compressMinBytes) {\n    let { flags, data } = envelope;\n    if ((flags & compressedFlag) === compressedFlag) {\n        throw new ConnectError(\"invalid envelope, already compressed\", Code.Internal);\n    }\n    if (compression && data.byteLength >= compressMinBytes) {\n        data = await compression.compress(data);\n        flags = flags | compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Decompress an EnvelopedMessage.\n *\n * Raises InvalidArgument if an envelope is compressed, but compression is null.\n *\n * Relies on the provided Compression to raise ResourceExhausted if the\n * *decompressed* message size is larger than readMaxBytes. If the envelope is\n * not compressed, readMaxBytes is not honored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport async function envelopeDecompress(envelope, compression, readMaxBytes) {\n    let { flags, data } = envelope;\n    if ((flags & compressedFlag) === compressedFlag) {\n        if (!compression) {\n            throw new ConnectError(\"received compressed envelope, but do not know how to decompress\", Code.Internal);\n        }\n        data = await compression.decompress(data, readMaxBytes);\n        flags = flags ^ compressedFlag;\n    }\n    return { data, flags };\n}\n/**\n * Encode a single enveloped message.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function encodeEnvelope(flags, data) {\n    const bytes = new Uint8Array(data.length + 5);\n    bytes.set(data, 5);\n    const v = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    v.setUint8(0, flags); // first byte is flags\n    v.setUint32(1, data.length); // 4 bytes message length\n    return bytes;\n}\n/**\n * Encode a set of enveloped messages.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function encodeEnvelopes(...envelopes) {\n    const len = envelopes.reduce((previousValue, currentValue) => previousValue + currentValue.data.length + 5, 0);\n    const bytes = new Uint8Array(len);\n    const v = new DataView(bytes.buffer);\n    let offset = 0;\n    for (const e of envelopes) {\n        v.setUint8(offset, e.flags); // first byte is flags\n        v.setUint32(offset + 1, e.data.length); // 4 bytes message length\n        bytes.set(e.data, offset + 5);\n        offset += e.data.length + 5;\n    }\n    return bytes;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * At most, allow ~4GiB to be received or sent per message.\n * zlib used by Node.js caps maxOutputLength at this value. It also happens to\n * be the maximum theoretical message size supported by protobuf-es.\n */\nconst maxReadMaxBytes = 0xffffffff;\nconst maxWriteMaxBytes = maxReadMaxBytes;\n/**\n * The default value for the compressMinBytes option. The CPU cost of compressing\n * very small messages usually isn't worth the small reduction in network I/O, so\n * the default value is 1 kibibyte.\n */\nconst defaultCompressMinBytes = 1024;\n/**\n * Asserts that the options writeMaxBytes, readMaxBytes, and compressMinBytes\n * are within sane limits, and returns default values where no value is\n * provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateReadWriteMaxBytes(readMaxBytes, writeMaxBytes, compressMinBytes) {\n    writeMaxBytes !== null && writeMaxBytes !== void 0 ? writeMaxBytes : (writeMaxBytes = maxWriteMaxBytes);\n    readMaxBytes !== null && readMaxBytes !== void 0 ? readMaxBytes : (readMaxBytes = maxReadMaxBytes);\n    compressMinBytes !== null && compressMinBytes !== void 0 ? compressMinBytes : (compressMinBytes = defaultCompressMinBytes);\n    if (writeMaxBytes < 1 || writeMaxBytes > maxWriteMaxBytes) {\n        throw new ConnectError(`writeMaxBytes ${writeMaxBytes} must be >= 1 and <= ${maxWriteMaxBytes}`, Code.Internal);\n    }\n    if (readMaxBytes < 1 || readMaxBytes > maxReadMaxBytes) {\n        throw new ConnectError(`readMaxBytes ${readMaxBytes} must be >= 1 and <= ${maxReadMaxBytes}`, Code.Internal);\n    }\n    return {\n        readMaxBytes,\n        writeMaxBytes,\n        compressMinBytes,\n    };\n}\n/**\n * Raise an error ResourceExhausted if more than writeMaxByte are written.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function assertWriteMaxBytes(writeMaxBytes, bytesWritten) {\n    if (bytesWritten > writeMaxBytes) {\n        throw new ConnectError(`message size ${bytesWritten} is larger than configured writeMaxBytes ${writeMaxBytes}`, Code.ResourceExhausted);\n    }\n}\n/**\n * Raise an error ResourceExhausted if more than readMaxBytes are read.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function assertReadMaxBytes(readMaxBytes, bytesRead, totalSizeKnown = false) {\n    if (bytesRead > readMaxBytes) {\n        let message = `message size is larger than configured readMaxBytes ${readMaxBytes}`;\n        if (totalSizeKnown) {\n            message = `message size ${bytesRead} is larger than configured readMaxBytes ${readMaxBytes}`;\n        }\n        throw new ConnectError(message, Code.ResourceExhausted);\n    }\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { encodeEnvelope, envelopeCompress, envelopeDecompress, } from \"./envelope.js\";\nimport { assertReadMaxBytes } from \"./limit-io.js\";\nexport function pipeTo(source, ...rest) {\n    const [transforms, sink, opt] = pickTransformsAndSink(rest);\n    let iterable = source;\n    let abortable;\n    if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n        iterable = abortable = makeIterableAbortable(iterable);\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    iterable = pipe(iterable, ...transforms, { propagateDownStreamError: false });\n    return sink(iterable).catch((reason) => {\n        if (abortable) {\n            return abortable.abort(reason).then(() => Promise.reject(reason));\n        }\n        return Promise.reject(reason);\n    });\n}\n// pick transforms, the sink, and options from the pipeTo() rest parameter\nfunction pickTransformsAndSink(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    const sink = rest.pop();\n    return [rest, sink, opt];\n}\n/**\n * Creates an AsyncIterableSink that concatenates all elements from the input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function sinkAll() {\n    return async function (iterable) {\n        var _a, e_1, _b, _c;\n        const all = [];\n        try {\n            for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = await iterable_1.next(), _a = iterable_1_1.done, !_a; _d = true) {\n                _c = iterable_1_1.value;\n                _d = false;\n                const chunk = _c;\n                all.push(chunk);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = iterable_1.return)) await _b.call(iterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return all;\n    };\n}\n/**\n * Creates an AsyncIterableSink that concatenates all chunks from the input into\n * a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function sinkAllBytes(readMaxBytes, lengthHint) {\n    return async function (iterable) {\n        return await readAllBytes(iterable, readMaxBytes, lengthHint);\n    };\n}\nexport function pipe(source, ...rest) {\n    return __asyncGenerator(this, arguments, function* pipe_1() {\n        var _a;\n        const [transforms, opt] = pickTransforms(rest);\n        let abortable;\n        const sourceIt = source[Symbol.asyncIterator]();\n        const cachedSource = {\n            [Symbol.asyncIterator]() {\n                return sourceIt;\n            },\n        };\n        let iterable = cachedSource;\n        if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n            iterable = abortable = makeIterableAbortable(iterable);\n        }\n        for (const t of transforms) {\n            iterable = t(iterable);\n        }\n        const it = iterable[Symbol.asyncIterator]();\n        try {\n            for (;;) {\n                const r = yield __await(it.next());\n                if (r.done === true) {\n                    break;\n                }\n                if (!abortable) {\n                    yield yield __await(r.value);\n                    continue;\n                }\n                try {\n                    yield yield __await(r.value);\n                }\n                catch (e) {\n                    yield __await(abortable.abort(e)); // propagate downstream error to the source\n                    throw e;\n                }\n            }\n        }\n        finally {\n            if ((opt === null || opt === void 0 ? void 0 : opt.propagateDownStreamError) === true) {\n                // Call return on the source iterable to indicate\n                // that we will no longer consume it and it should\n                // cleanup any allocated resources.\n                (_a = sourceIt.return) === null || _a === void 0 ? void 0 : _a.call(sourceIt).catch(() => {\n                    // return returns a promise, which we don't care about.\n                    //\n                    // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                    // this is to ensure error is caught and ignored.\n                });\n            }\n        }\n    });\n}\nfunction pickTransforms(rest) {\n    let opt;\n    if (typeof rest[rest.length - 1] != \"function\") {\n        opt = rest.pop();\n    }\n    return [rest, opt];\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given catchError function.\n *\n * The catchError function may return a final value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformCatch(catchError) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    const caught = yield __await(catchError(e));\n                    if (caught !== undefined) {\n                        yield yield __await(caught);\n                    }\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that catches any error from the input, and\n * passes it to the given function. Unlike transformCatch(), the given function\n * is also called when no error is raised.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformCatchFinally(catchFinally) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            // we deliberate avoid a for-await loop because we only want to catch upstream\n            // errors, not downstream errors (yield).\n            let err;\n            const it = iterable[Symbol.asyncIterator]();\n            for (;;) {\n                let r;\n                try {\n                    r = yield __await(it.next());\n                }\n                catch (e) {\n                    err = e;\n                    break;\n                }\n                if (r.done === true) {\n                    break;\n                }\n                yield yield __await(r.value);\n            }\n            const caught = yield __await(catchFinally(err));\n            if (caught !== undefined) {\n                yield yield __await(caught);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that appends a value.\n *\n * The element to append is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformAppend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_2, _b, _c;\n            try {\n                for (var _d = true, iterable_2 = __asyncValues(iterable), iterable_2_1; iterable_2_1 = yield __await(iterable_2.next()), _a = iterable_2_1.done, !_a; _d = true) {\n                    _c = iterable_2_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_2.return)) yield __await(_b.call(iterable_2));\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            const append = yield __await(provide());\n            if (append !== undefined) {\n                yield yield __await(append);\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that prepends an element.\n *\n * The element to prepend is provided by a function. If the function returns\n * undefined, no element is appended.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformPrepend(provide) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_3, _b, _c;\n            const prepend = yield __await(provide());\n            if (prepend !== undefined) {\n                yield yield __await(prepend);\n            }\n            try {\n                for (var _d = true, iterable_3 = __asyncValues(iterable), iterable_3_1; iterable_3_1 = yield __await(iterable_3.next()), _a = iterable_3_1.done, !_a; _d = true) {\n                    _c = iterable_3_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_3.return)) yield __await(_b.call(iterable_3));\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that reads all bytes from the input, and\n * concatenates them to a single Uint8Array.\n *\n * The iterable raises an error if the more than readMaxBytes are read.\n *\n * An optional length hint can be provided to optimize allocation and validation.\n * If more or less bytes are present in the source that the length hint indicates,\n * and error is raised.\n * If the length hint is larger than readMaxBytes, an error is raised.\n * If the length hint is not a positive integer, it is ignored.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformReadAllBytes(readMaxBytes, lengthHint) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            yield yield __await(yield __await(readAllBytes(iterable, readMaxBytes, lengthHint)));\n        });\n    };\n}\nexport function transformSerializeEnvelope(serialization, endStreamFlag, endSerialization) {\n    if (endStreamFlag === undefined || endSerialization === undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_4, _b, _c;\n                try {\n                    for (var _d = true, iterable_4 = __asyncValues(iterable), iterable_4_1; iterable_4_1 = yield __await(iterable_4.next()), _a = iterable_4_1.done, !_a; _d = true) {\n                        _c = iterable_4_1.value;\n                        _d = false;\n                        const chunk = _c;\n                        const data = serialization.serialize(chunk);\n                        yield yield __await({ flags: 0, data });\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_4.return)) yield __await(_b.call(iterable_4));\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            });\n        };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_5, _b, _c;\n            try {\n                for (var _d = true, iterable_5 = __asyncValues(iterable), iterable_5_1; iterable_5_1 = yield __await(iterable_5.next()), _a = iterable_5_1.done, !_a; _d = true) {\n                    _c = iterable_5_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    let data;\n                    let flags = 0;\n                    if (chunk.end) {\n                        flags = flags | endStreamFlag;\n                        data = endSerialization.serialize(chunk.value);\n                    }\n                    else {\n                        data = serialization.serialize(chunk.value);\n                    }\n                    yield yield __await({ flags, data });\n                }\n            }\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_5.return)) yield __await(_b.call(iterable_5));\n                }\n                finally { if (e_5) throw e_5.error; }\n            }\n        });\n    };\n}\nexport function transformParseEnvelope(serialization, endStreamFlag, endSerialization) {\n    // code path always yields ParsedEnvelopedMessage<T, E>\n    if (endSerialization && endStreamFlag !== undefined) {\n        return function (iterable) {\n            return __asyncGenerator(this, arguments, function* () {\n                var _a, e_6, _b, _c;\n                try {\n                    for (var _d = true, iterable_6 = __asyncValues(iterable), iterable_6_1; iterable_6_1 = yield __await(iterable_6.next()), _a = iterable_6_1.done, !_a; _d = true) {\n                        _c = iterable_6_1.value;\n                        _d = false;\n                        const { flags, data } = _c;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            yield yield __await({ value: endSerialization.parse(data), end: true });\n                        }\n                        else {\n                            yield yield __await({ value: serialization.parse(data), end: false });\n                        }\n                    }\n                }\n                catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = iterable_6.return)) yield __await(_b.call(iterable_6));\n                    }\n                    finally { if (e_6) throw e_6.error; }\n                }\n            });\n        };\n    }\n    // code path always yields T\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_7, _b, _c;\n            try {\n                for (var _d = true, iterable_7 = __asyncValues(iterable), iterable_7_1; iterable_7_1 = yield __await(iterable_7.next()), _a = iterable_7_1.done, !_a; _d = true) {\n                    _c = iterable_7_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    if (endStreamFlag !== undefined &&\n                        (flags & endStreamFlag) === endStreamFlag) {\n                        if (endSerialization === null) {\n                            throw new ConnectError(\"unexpected end flag\", Code.InvalidArgument);\n                        }\n                        // skips end-of-stream envelope\n                        continue;\n                    }\n                    yield yield __await(serialization.parse(data));\n                }\n            }\n            catch (e_7_1) { e_7 = { error: e_7_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_7.return)) yield __await(_b.call(iterable_7));\n                }\n                finally { if (e_7) throw e_7.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and compresses them if they are larger than compressMinBytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformCompressEnvelope(compression, compressMinBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_8, _b, _c;\n            try {\n                for (var _d = true, iterable_8 = __asyncValues(iterable), iterable_8_1; iterable_8_1 = yield __await(iterable_8.next()), _a = iterable_8_1.done, !_a; _d = true) {\n                    _c = iterable_8_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await(envelopeCompress(env, compression, compressMinBytes)));\n                }\n            }\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_8.return)) yield __await(_b.call(iterable_8));\n                }\n                finally { if (e_8) throw e_8.error; }\n            }\n        });\n    };\n}\n/**\n * Creates an AsyncIterableTransform that takes enveloped messages as a source,\n * and decompresses them using the given compression.\n *\n * The iterable raises an error if the decompressed payload of an enveloped\n * message is larger than readMaxBytes, or if no compression is provided.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformDecompressEnvelope(compression, readMaxBytes) {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_9, _b, _c;\n            try {\n                for (var _d = true, iterable_9 = __asyncValues(iterable), iterable_9_1; iterable_9_1 = yield __await(iterable_9.next()), _a = iterable_9_1.done, !_a; _d = true) {\n                    _c = iterable_9_1.value;\n                    _d = false;\n                    const env = _c;\n                    yield yield __await(yield __await(envelopeDecompress(env, compression, readMaxBytes)));\n                }\n            }\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_9.return)) yield __await(_b.call(iterable_9));\n                }\n                finally { if (e_9) throw e_9.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes enveloped messages as a source,\n * and joins them into a stream of raw bytes.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformJoinEnvelopes() {\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_10, _b, _c;\n            try {\n                for (var _d = true, iterable_10 = __asyncValues(iterable), iterable_10_1; iterable_10_1 = yield __await(iterable_10.next()), _a = iterable_10_1.done, !_a; _d = true) {\n                    _c = iterable_10_1.value;\n                    _d = false;\n                    const { flags, data } = _c;\n                    yield yield __await(encodeEnvelope(flags, data));\n                }\n            }\n            catch (e_10_1) { e_10 = { error: e_10_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_10.return)) yield __await(_b.call(iterable_10));\n                }\n                finally { if (e_10) throw e_10.error; }\n            }\n        });\n    };\n}\n/**\n * Create an AsyncIterableTransform that takes raw bytes as a source, and splits\n * them into enveloped messages.\n *\n * The iterable raises an error\n * - if the payload of an enveloped message is larger than readMaxBytes,\n * - if the stream ended before an enveloped message fully arrived,\n * - or if the stream ended with extraneous data.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformSplitEnvelope(readMaxBytes) {\n    // append chunk to buffer, returning updated buffer\n    function append(buffer, chunk) {\n        const n = new Uint8Array(buffer.byteLength + chunk.byteLength);\n        n.set(buffer);\n        n.set(chunk, buffer.length);\n        return n;\n    }\n    // tuple 0: envelope, or undefined if incomplete\n    // tuple 1: remainder of the buffer\n    function shiftEnvelope(buffer, header) {\n        if (buffer.byteLength < 5 + header.length) {\n            return [undefined, buffer];\n        }\n        return [\n            { flags: header.flags, data: buffer.subarray(5, 5 + header.length) },\n            buffer.subarray(5 + header.length),\n        ];\n    }\n    // undefined: header is incomplete\n    function peekHeader(buffer) {\n        if (buffer.byteLength < 5) {\n            return undefined;\n        }\n        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n        const length = view.getUint32(1); // 4 bytes message length\n        const flags = view.getUint8(0); // first byte is flags\n        return { length, flags };\n    }\n    return function (iterable) {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, e_11, _b, _c;\n            let buffer = new Uint8Array(0);\n            try {\n                for (var _d = true, iterable_11 = __asyncValues(iterable), iterable_11_1; iterable_11_1 = yield __await(iterable_11.next()), _a = iterable_11_1.done, !_a; _d = true) {\n                    _c = iterable_11_1.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffer = append(buffer, chunk);\n                    for (;;) {\n                        const header = peekHeader(buffer);\n                        if (!header) {\n                            break;\n                        }\n                        assertReadMaxBytes(readMaxBytes, header.length, true);\n                        let env;\n                        [env, buffer] = shiftEnvelope(buffer, header);\n                        if (!env) {\n                            break;\n                        }\n                        yield yield __await(env);\n                    }\n                }\n            }\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iterable_11.return)) yield __await(_b.call(iterable_11));\n                }\n                finally { if (e_11) throw e_11.error; }\n            }\n            if (buffer.byteLength > 0) {\n                const header = peekHeader(buffer);\n                let message = \"protocol error: incomplete envelope\";\n                if (header) {\n                    message = `protocol error: promised ${header.length} bytes in enveloped message, got ${buffer.byteLength - 5} bytes`;\n                }\n                throw new ConnectError(message, Code.InvalidArgument);\n            }\n        });\n    };\n}\n/**\n * Reads all bytes from the source, and concatenates them to a single Uint8Array.\n *\n * Raises an error if:\n * - more than readMaxBytes are read\n * - lengthHint is a positive integer, but larger than readMaxBytes\n * - lengthHint is a positive integer, and the source contains more or less bytes\n *   than promised\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport async function readAllBytes(iterable, readMaxBytes, lengthHint) {\n    var _a, e_12, _b, _c, _d, e_13, _e, _f;\n    const [ok, hint] = parseLengthHint(lengthHint);\n    if (ok) {\n        if (hint > readMaxBytes) {\n            assertReadMaxBytes(readMaxBytes, hint, true);\n        }\n        const buffer = new Uint8Array(hint);\n        let offset = 0;\n        try {\n            for (var _g = true, iterable_12 = __asyncValues(iterable), iterable_12_1; iterable_12_1 = await iterable_12.next(), _a = iterable_12_1.done, !_a; _g = true) {\n                _c = iterable_12_1.value;\n                _g = false;\n                const chunk = _c;\n                if (offset + chunk.byteLength > hint) {\n                    throw new ConnectError(`protocol error: promised ${hint} bytes, received ${offset + chunk.byteLength}`, Code.InvalidArgument);\n                }\n                buffer.set(chunk, offset);\n                offset += chunk.byteLength;\n            }\n        }\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\n        finally {\n            try {\n                if (!_g && !_a && (_b = iterable_12.return)) await _b.call(iterable_12);\n            }\n            finally { if (e_12) throw e_12.error; }\n        }\n        if (offset < hint) {\n            throw new ConnectError(`protocol error: promised ${hint} bytes, received ${offset}`, Code.InvalidArgument);\n        }\n        return buffer;\n    }\n    const chunks = [];\n    let count = 0;\n    try {\n        for (var _h = true, iterable_13 = __asyncValues(iterable), iterable_13_1; iterable_13_1 = await iterable_13.next(), _d = iterable_13_1.done, !_d; _h = true) {\n            _f = iterable_13_1.value;\n            _h = false;\n            const chunk = _f;\n            count += chunk.byteLength;\n            assertReadMaxBytes(readMaxBytes, count);\n            chunks.push(chunk);\n        }\n    }\n    catch (e_13_1) { e_13 = { error: e_13_1 }; }\n    finally {\n        try {\n            if (!_h && !_d && (_e = iterable_13.return)) await _e.call(iterable_13);\n        }\n        finally { if (e_13) throw e_13.error; }\n    }\n    const all = new Uint8Array(count);\n    let offset = 0;\n    for (let chunk = chunks.shift(); chunk; chunk = chunks.shift()) {\n        all.set(chunk, offset);\n        offset += chunk.byteLength;\n    }\n    return all;\n}\n// parse the lengthHint argument of readAllBytes()\nfunction parseLengthHint(lengthHint) {\n    if (lengthHint === undefined || lengthHint === null) {\n        return [false, 0];\n    }\n    const n = typeof lengthHint == \"string\" ? parseInt(lengthHint, 10) : lengthHint;\n    if (!Number.isSafeInteger(n) || n < 0) {\n        return [false, n];\n    }\n    return [true, n];\n}\n/**\n * Wait for the first element of an iterable without modifying the iterable.\n * This consumes the first element, but pushes it back on the stack.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport async function untilFirst(iterable) {\n    const it = iterable[Symbol.asyncIterator]();\n    let first = await it.next();\n    return {\n        [Symbol.asyncIterator]() {\n            const w = {\n                async next() {\n                    if (first !== null) {\n                        const n = first;\n                        first = null;\n                        return n;\n                    }\n                    return await it.next();\n                },\n            };\n            if (it.throw !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- can't handle mutated object sensibly\n                w.throw = (e) => it.throw(e);\n            }\n            if (it.return !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-explicit-any -- can't handle mutated object sensibly\n                w.return = (value) => it.return(value);\n            }\n            return w;\n        },\n    };\n}\n/**\n * Wrap the given iterable and return an iterable with an abort() method.\n *\n * This function exists purely for convenience. Where one would typically have\n * to access the iterator directly, advance through all elements, and call\n * AsyncIterator.throw() to notify the upstream iterable, this function allows\n * to use convenient for-await loops and still notify the upstream iterable:\n *\n * ```ts\n * const abortable = makeIterableAbortable(iterable);\n * for await (const ele of abortable) {\n *   await abortable.abort(\"ERR\");\n * }\n * ```\n * There are a couple of limitations of this function:\n * - the given async iterable must implement throw\n * - the async iterable cannot be re-use\n * - if source catches errors and yields values for them, they are ignored, and\n *   the source may still dangle\n *\n * There are four possible ways an async function* can handle yield errors:\n * 1. don't catch errors at all - Abortable.abort() will resolve \"rethrown\"\n * 2. catch errors and rethrow - Abortable.abort() will resolve \"rethrown\"\n * 3. catch errors and return - Abortable.abort() will resolve \"completed\"\n * 4. catch errors and yield a value - Abortable.abort() will resolve \"caught\"\n *\n * Note that catching errors and yielding a value is problematic, and it should\n * be documented that this may leave the source in a dangling state.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function makeIterableAbortable(iterable) {\n    const innerCandidate = iterable[Symbol.asyncIterator]();\n    if (innerCandidate.throw === undefined) {\n        throw new Error(\"AsyncIterable does not implement throw\");\n    }\n    const inner = innerCandidate;\n    let aborted;\n    let resultPromise;\n    let it = {\n        next() {\n            resultPromise = inner.next().finally(() => {\n                resultPromise = undefined;\n            });\n            return resultPromise;\n        },\n        throw(e) {\n            return inner.throw(e);\n        },\n    };\n    if (innerCandidate.return !== undefined) {\n        it = Object.assign(Object.assign({}, it), { return(value) {\n                return inner.return(value);\n            } });\n    }\n    let used = false;\n    return {\n        abort(reason) {\n            if (aborted) {\n                return aborted.state;\n            }\n            const f = () => {\n                return inner.throw(reason).then((r) => (r.done === true ? \"completed\" : \"caught\"), () => \"rethrown\");\n            };\n            if (resultPromise) {\n                aborted = { reason, state: resultPromise.then(f, f) };\n                return aborted.state;\n            }\n            aborted = { reason, state: f() };\n            return aborted.state;\n        },\n        [Symbol.asyncIterator]() {\n            if (used) {\n                throw new Error(\"AsyncIterable cannot be re-used\");\n            }\n            used = true;\n            return it;\n        },\n    };\n}\n/**\n * Create a new WritableIterable.\n */\nexport function createWritableIterable() {\n    // We start with two queues to capture the read and write attempts.\n    //\n    // The writes and reads each check of their counterpart is\n    // already available and either interact/add themselves to the queue.\n    const readQueue = [];\n    const writeQueue = [];\n    let err = undefined;\n    let nextResolve;\n    let nextReject;\n    let nextPromise = new Promise((resolve, reject) => {\n        nextResolve = resolve;\n        nextReject = reject;\n    });\n    let closed = false;\n    // drain the readQueue in case of error/writer is closed by sending a\n    // done result.\n    function drain() {\n        for (const next of readQueue.splice(0, readQueue.length)) {\n            next({ done: true, value: undefined });\n        }\n    }\n    return {\n        close() {\n            closed = true;\n            drain();\n        },\n        async write(payload) {\n            if (closed) {\n                throw err !== null && err !== void 0 ? err : new Error(\"cannot write, WritableIterable already closed\");\n            }\n            const read = readQueue.shift();\n            if (read === undefined) {\n                // We didn't find a pending read so we add the payload to the write queue.\n                writeQueue.push(payload);\n            }\n            else {\n                // We found a pending read so we respond with the payload.\n                read({ done: false, value: payload });\n                if (readQueue.length > 0) {\n                    // If there are more in the read queue we can mark the write as complete.\n                    // as the error reporting is not guaranteed to be sequential and therefore cannot\n                    // to linked to a specific write.\n                    return;\n                }\n            }\n            // We await the next call for as many times as there are items in the queue + 1\n            //\n            // If there are no items in the write queue that means write happened and we just have\n            // to wait for one more call likewise if we are the nth write in the queue we\n            // have to wait for n writes to complete and one more.\n            const limit = writeQueue.length + 1;\n            for (let i = 0; i < limit; i++) {\n                await nextPromise;\n            }\n        },\n        [Symbol.asyncIterator]() {\n            return {\n                next() {\n                    // Resolve the nextPromise to indicate\n                    // pending writes that a read attempt has been made\n                    // after their write.\n                    //\n                    // We also need to reset the promise for future writes.\n                    nextResolve();\n                    nextPromise = new Promise((resolve, reject) => {\n                        nextResolve = resolve;\n                        nextReject = reject;\n                    });\n                    const write = writeQueue.shift();\n                    if (write !== undefined) {\n                        // We found a pending write so response with the payload.\n                        return Promise.resolve({ done: false, value: write });\n                    }\n                    if (closed) {\n                        return Promise.resolve({ done: true, value: undefined });\n                    }\n                    // We return a promise immediately that is either resolved/rejected\n                    // as writes happen.\n                    let readResolve;\n                    const readPromise = new Promise((resolve) => (readResolve = resolve));\n                    readQueue.push(readResolve); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                    return readPromise;\n                },\n                throw(throwErr) {\n                    err = throwErr;\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    // This will reject all pending writes.\n                    nextReject(err);\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n                return() {\n                    closed = true;\n                    writeQueue.splice(0, writeQueue.length);\n                    // Resolve once for the write awaiting confirmation.\n                    nextResolve();\n                    // Reject all future writes.\n                    nextPromise = Promise.reject(new Error(\"cannot write, consumer called return\"));\n                    nextPromise.catch(() => {\n                        // To make sure that the nextPromise is always resolved.\n                    });\n                    drain();\n                    return Promise.resolve({ done: true, value: undefined });\n                },\n            };\n        },\n    };\n}\n/**\n * Create an asynchronous iterable from an array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport function createAsyncIterable(items) {\n    return __asyncGenerator(this, arguments, function* createAsyncIterable_1() {\n        yield __await(yield* __asyncDelegator(__asyncValues(items)));\n    });\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { Message, MethodKind } from \"@bufbuild/protobuf\";\nimport { ConnectError } from \"./connect-error.js\";\nimport { Code } from \"./code.js\";\nimport { makeAnyClient } from \"./any-client.js\";\nimport { createAsyncIterable } from \"./protocol/async-iterable.js\";\n/**\n * Create a CallbackClient for the given service, invoking RPCs through the\n * given transport.\n */\nexport function createCallbackClient(service, transport) {\n    return makeAnyClient(service, (method) => {\n        switch (method.kind) {\n            case MethodKind.Unary:\n                return createUnaryFn(transport, service, method);\n            case MethodKind.ServerStreaming:\n                return createServerStreamingFn(transport, service, method);\n            default:\n                return null;\n        }\n    });\n}\nfunction createUnaryFn(transport, service, method) {\n    return function (requestMessage, callback, options) {\n        const abort = new AbortController();\n        options = wrapSignal(abort, options);\n        transport\n            .unary(service, method, abort.signal, options.timeoutMs, options.headers, requestMessage, options.contextValues)\n            .then((response) => {\n            var _a, _b;\n            (_a = options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            (_b = options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n            callback(undefined, response.message);\n        }, (reason) => {\n            const err = ConnectError.from(reason, Code.Internal);\n            if (err.code === Code.Canceled && abort.signal.aborted) {\n                // As documented, discard Canceled errors if canceled by the user.\n                return;\n            }\n            callback(err, new method.O());\n        });\n        return () => abort.abort();\n    };\n}\nfunction createServerStreamingFn(transport, service, method) {\n    return function (input, onResponse, onClose, options) {\n        const abort = new AbortController();\n        async function run() {\n            var _a, e_1, _b, _c;\n            var _d, _e;\n            options = wrapSignal(abort, options);\n            const response = await transport.stream(service, method, options.signal, options.timeoutMs, options.headers, createAsyncIterable([input]), options.contextValues);\n            (_d = options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n            try {\n                for (var _f = true, _g = __asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const message = _c;\n                    onResponse(message);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            (_e = options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n            onClose(undefined);\n        }\n        run().catch((reason) => {\n            const err = ConnectError.from(reason, Code.Internal);\n            if (err.code === Code.Canceled && abort.signal.aborted) {\n                // As documented, discard Canceled errors if canceled by the user,\n                // but do invoke the close-callback.\n                onClose(undefined);\n            }\n            else {\n                onClose(err);\n            }\n        });\n        return () => abort.abort();\n    };\n}\nfunction wrapSignal(abort, options) {\n    if (options === null || options === void 0 ? void 0 : options.signal) {\n        options.signal.addEventListener(\"abort\", () => abort.abort());\n        if (options.signal.aborted) {\n            abort.abort();\n        }\n    }\n    return Object.assign(Object.assign({}, options), { signal: abort.signal });\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { Message, MethodKind } from \"@bufbuild/protobuf\";\nimport { makeAnyClient } from \"./any-client.js\";\nimport { ConnectError } from \"./connect-error.js\";\nimport { Code } from \"./code.js\";\nimport { createAsyncIterable } from \"./protocol/async-iterable.js\";\n/**\n * Create a Client for the given service, invoking RPCs through the\n * given transport.\n */\nexport function createClient(service, transport) {\n    return makeAnyClient(service, (method) => {\n        switch (method.kind) {\n            case MethodKind.Unary:\n                return createUnaryFn(transport, service, method);\n            case MethodKind.ServerStreaming:\n                return createServerStreamingFn(transport, service, method);\n            case MethodKind.ClientStreaming:\n                return createClientStreamingFn(transport, service, method);\n            case MethodKind.BiDiStreaming:\n                return createBiDiStreamingFn(transport, service, method);\n            default:\n                return null;\n        }\n    });\n}\n/**\n * @deprecated use createClient.\n */\nexport function createPromiseClient(service, transport) {\n    return createClient(service, transport);\n}\nexport function createUnaryFn(transport, service, method) {\n    return async function (input, options) {\n        var _a, _b;\n        const response = await transport.unary(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n        (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        return response.message;\n    };\n}\nexport function createServerStreamingFn(transport, service, method) {\n    return function (input, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, createAsyncIterable([input]), options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nexport function createClientStreamingFn(transport, service, method) {\n    return async function (request, options) {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        const response = await transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);\n        (_d = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d === void 0 ? void 0 : _d.call(options, response.header);\n        let singleMessage;\n        let count = 0;\n        try {\n            for (var _f = true, _g = __asyncValues(response.message), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                _c = _h.value;\n                _f = false;\n                const message = _c;\n                singleMessage = message;\n                count++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!singleMessage) {\n            throw new ConnectError(\"protocol error: missing response message\", Code.Unimplemented);\n        }\n        if (count > 1) {\n            throw new ConnectError(\"protocol error: received extra messages for client streaming method\", Code.Unimplemented);\n        }\n        (_e = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e === void 0 ? void 0 : _e.call(options, response.trailer);\n        return singleMessage;\n    };\n}\nexport function createBiDiStreamingFn(transport, service, method) {\n    return function (request, options) {\n        return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);\n    };\n}\nfunction handleStreamResponse(stream, options) {\n    const it = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            var _a, _b;\n            const response = yield __await(stream);\n            (_a = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a === void 0 ? void 0 : _a.call(options, response.header);\n            yield __await(yield* __asyncDelegator(__asyncValues(response.message)));\n            (_b = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b === void 0 ? void 0 : _b.call(options, response.trailer);\n        });\n    })()[Symbol.asyncIterator]();\n    // Create a new iterable to omit throw/return.\n    return {\n        [Symbol.asyncIterator]: () => ({\n            next: () => it.next(),\n        }),\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * Create an AbortController that is automatically aborted if one of the given\n * signals is aborted.\n *\n * For convenience, the linked AbortSignals can be undefined.\n *\n * If the controller or any of the signals is aborted, all event listeners are\n * removed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createLinkedAbortController(...signals) {\n    const controller = new AbortController();\n    const sa = signals.filter((s) => s !== undefined).concat(controller.signal);\n    for (const signal of sa) {\n        if (signal.aborted) {\n            onAbort.apply(signal);\n            break;\n        }\n        signal.addEventListener(\"abort\", onAbort);\n    }\n    function onAbort() {\n        if (!controller.signal.aborted) {\n            controller.abort(getAbortSignalReason(this));\n        }\n        for (const signal of sa) {\n            signal.removeEventListener(\"abort\", onAbort);\n        }\n    }\n    return controller;\n}\n/**\n * Create a deadline signal. The returned object contains an AbortSignal, but\n * also a cleanup function to stop the timer, which must be called once the\n * calling code is no longer interested in the signal.\n *\n * Ideally, we would simply use AbortSignal.timeout(), but it is not widely\n * available yet.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createDeadlineSignal(timeoutMs) {\n    const controller = new AbortController();\n    const listener = () => {\n        controller.abort(new ConnectError(\"the operation timed out\", Code.DeadlineExceeded));\n    };\n    let timeoutId;\n    if (timeoutMs !== undefined) {\n        if (timeoutMs <= 0)\n            listener();\n        else\n            timeoutId = setTimeout(listener, timeoutMs);\n    }\n    return {\n        signal: controller.signal,\n        cleanup: () => clearTimeout(timeoutId),\n    };\n}\n/**\n * Returns the reason why an AbortSignal was aborted. Returns undefined if the\n * signal has not been aborted.\n *\n * The property AbortSignal.reason is not widely available. This function\n * returns an AbortError if the signal is aborted, but reason is undefined.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function getAbortSignalReason(signal) {\n    if (!signal.aborted) {\n        return undefined;\n    }\n    if (signal.reason !== undefined) {\n        return signal.reason;\n    }\n    // AbortSignal.reason is available in Node.js v16, v18, and later,\n    // and in all browsers since early 2022.\n    const e = new Error(\"This operation was aborted\");\n    e.name = \"AbortError\";\n    return e;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * createContextValues creates a new ContextValues.\n */\nexport function createContextValues() {\n    return {\n        get(key) {\n            return key.id in this ? this[key.id] : key.defaultValue;\n        },\n        set(key, value) {\n            this[key.id] = value;\n            return this;\n        },\n        delete(key) {\n            delete this[key.id];\n            return this;\n        },\n    };\n}\n/**\n * createContextKey creates a new ContextKey.\n */\nexport function createContextKey(defaultValue, options) {\n    return { id: Symbol(options === null || options === void 0 ? void 0 : options.description), defaultValue };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { MethodKind } from \"@bufbuild/protobuf\";\nimport { ConnectError } from \"./connect-error.js\";\nimport { Code } from \"./code.js\";\nimport { createDeadlineSignal, createLinkedAbortController, } from \"./protocol/signals.js\";\nimport { createContextValues } from \"./context-values.js\";\n/**\n * Create a new HandlerContext.\n *\n * The context is usually automatically created by handlers, but if a service\n * implementation is used in unit tests, this function can be used to create\n * a context.\n */\nexport function createHandlerContext(init) {\n    var _a;\n    let timeoutMs;\n    if (init.timeoutMs !== undefined) {\n        const date = new Date(Date.now() + init.timeoutMs);\n        timeoutMs = () => date.getTime() - Date.now();\n    }\n    else {\n        timeoutMs = () => undefined;\n    }\n    const deadline = createDeadlineSignal(init.timeoutMs);\n    const abortController = createLinkedAbortController(deadline.signal, init.requestSignal, init.shutdownSignal);\n    return Object.assign(Object.assign({}, init), { signal: abortController.signal, timeoutMs, requestHeader: new Headers(init.requestHeader), responseHeader: new Headers(init.responseHeader), responseTrailer: new Headers(init.responseTrailer), abort(reason) {\n            deadline.cleanup();\n            abortController.abort(reason);\n        }, values: (_a = init.contextValues) !== null && _a !== void 0 ? _a : createContextValues() });\n}\n/**\n * Create an MethodImplSpec - a user-provided implementation for a method,\n * wrapped in a discriminated union type along with service and method metadata.\n */\nexport function createMethodImplSpec(service, method, impl) {\n    return {\n        kind: method.kind,\n        service,\n        method,\n        impl,\n    };\n}\n/**\n * Create an ServiceImplSpec - a user-provided service implementation wrapped\n * with metadata.\n */\nexport function createServiceImplSpec(service, impl) {\n    const s = { service, methods: {} };\n    for (const [localName, methodInfo] of Object.entries(service.methods)) {\n        let fn = impl[localName];\n        if (typeof fn == \"function\") {\n            fn = fn.bind(impl);\n        }\n        else {\n            const message = `${service.typeName}.${methodInfo.name} is not implemented`;\n            fn = function unimplemented() {\n                throw new ConnectError(message, Code.Unimplemented);\n            };\n        }\n        s.methods[localName] = createMethodImplSpec(service, methodInfo, fn);\n    }\n    return s;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * trailerFlag indicates that the data in a EnvelopedMessage\n * is a set of trailers of the gRPC-web protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const trailerFlag = 0b10000000;\n/**\n * Parse a gRPC-web trailer, a set of header fields separated by CRLF.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function trailerParse(data) {\n    const headers = new Headers();\n    const lines = new TextDecoder().decode(data).split(\"\\r\\n\");\n    for (const line of lines) {\n        if (line === \"\") {\n            continue;\n        }\n        const i = line.indexOf(\":\");\n        if (i > 0) {\n            const name = line.substring(0, i).trim();\n            const value = line.substring(i + 1).trim();\n            headers.append(name, value);\n        }\n    }\n    return headers;\n}\n/**\n * Serialize a Headers object as a gRPC-web trailer.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function trailerSerialize(trailer) {\n    const lines = [];\n    trailer.forEach((value, key) => {\n        lines.push(`${key}: ${value}\\r\\n`);\n    });\n    return new TextEncoder().encode(lines.join(\"\"));\n}\n/**\n * Create a Serialization object that serializes a gRPC-web trailer, a Headers\n * object that is serialized as a set of header fields, separated by CRLF.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createTrailerSerialization() {\n    return {\n        serialize: trailerSerialize,\n        parse: trailerParse,\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nexport const headerContentType = \"Content-Type\";\nexport const headerEncoding = \"Grpc-Encoding\";\nexport const headerAcceptEncoding = \"Grpc-Accept-Encoding\";\nexport const headerTimeout = \"Grpc-Timeout\";\nexport const headerGrpcStatus = \"Grpc-Status\";\nexport const headerGrpcMessage = \"Grpc-Message\";\nexport const headerStatusDetailsBin = \"Grpc-Status-Details-Bin\";\nexport const headerMessageType = \"Grpc-Message-Type\";\nexport const headerUserAgent = \"User-Agent\";\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nexport { headerContentType, headerEncoding, headerAcceptEncoding, headerTimeout, headerGrpcStatus, headerGrpcMessage, headerStatusDetailsBin, headerUserAgent, } from \"../protocol-grpc/headers.js\";\n/**\n * gRPC-web does not use the standard header User-Agent.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const headerXUserAgent = \"X-User-Agent\";\n/**\n * The canonical grpc/grpc-web JavaScript implementation sets\n * this request header with value \"1\".\n * Some servers may rely on the header to identify gRPC-web\n * requests. For example the proxy by improbable:\n * https://github.com/improbable-eng/grpc-web/blob/53aaf4cdc0fede7103c1b06f0cfc560c003a5c41/go/grpcweb/wrapper.go#L231\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const headerXGrpcWeb = \"X-Grpc-Web\";\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid gRPC-web Content-Type header value.\n * Note that this includes application/grpc-web-text with the additional base64\n * encoding.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const contentTypeRegExp = /^application\\/grpc-web(-text)?(?:\\+(?:(json)(?:; ?charset=utf-?8)?|proto))?$/i;\nexport const contentTypeProto = \"application/grpc-web+proto\";\nexport const contentTypeJson = \"application/grpc-web+json\";\n/**\n * Parse a gRPC-web Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const text = !!match[1];\n    const binary = !match[2];\n    return { text, binary };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\n/**\n * Parse a gRPC Timeout (Deadline) header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseTimeout(value, maxTimeoutMs) {\n    if (value === null) {\n        return {};\n    }\n    const results = /^(\\d{1,8})([HMSmun])$/.exec(value);\n    if (results === null) {\n        return {\n            error: new ConnectError(`protocol error: invalid grpc timeout value: ${value}`, Code.InvalidArgument),\n        };\n    }\n    const unitToMultiplicand = {\n        H: 60 * 60 * 1000, // hour\n        M: 60 * 1000, // minute\n        S: 1000, // second\n        m: 1, // millisecond\n        u: 0.001, // microsecond\n        n: 0.000001, // nanosecond\n    };\n    const timeoutMs = unitToMultiplicand[results[2]] *\n        parseInt(results[1]);\n    if (timeoutMs > maxTimeoutMs) {\n        return {\n            timeoutMs: timeoutMs,\n            error: new ConnectError(`timeout ${timeoutMs}ms must be <= ${maxTimeoutMs}`, Code.InvalidArgument),\n        };\n    }\n    return {\n        timeoutMs,\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Any, Message, proto3 } from \"@bufbuild/protobuf\";\n/**\n * The `Status` type defines a logical error model that is suitable for different\n * programming environments, including REST APIs and RPC APIs. It is used by\n * [gRPC](https://github.com/grpc). The error model is designed to be:\n *\n * - Simple to use and understand for most users\n * - Flexible enough to meet unexpected needs\n *\n * # Overview\n *\n * The `Status` message contains three pieces of data: error code, error message,\n * and error details. The error code should be an enum value of\n * [google.rpc.Code][google.rpc.Code], but it may accept additional error codes if needed.  The\n * error message should be a developer-facing English message that helps\n * developers *understand* and *resolve* the error. If a localized user-facing\n * error message is needed, put the localized message in the error details or\n * localize it in the client. The optional error details may contain arbitrary\n * information about the error. There is a predefined set of error detail types\n * in the package `google.rpc` which can be used for common error conditions.\n *\n * # Language mapping\n *\n * The `Status` message is the logical representation of the error model, but it\n * is not necessarily the actual wire format. When the `Status` message is\n * exposed in different client libraries and different wire protocols, it can be\n * mapped differently. For example, it will likely be mapped to some exceptions\n * in Java, but more likely mapped to some error codes in C.\n *\n * # Other uses\n *\n * The error model and the `Status` message can be used in a variety of\n * environments, either with or without APIs, to provide a\n * consistent developer experience across different environments.\n *\n * Example uses of this error model include:\n *\n * - Partial errors. If a service needs to return partial errors to the client,\n *     it may embed the `Status` in the normal response to indicate the partial\n *     errors.\n *\n * - Workflow errors. A typical workflow has multiple steps. Each step may\n *     have a `Status` message for error reporting purpose.\n *\n * - Batch operations. If a client uses batch request and batch response, the\n *     `Status` message should be used directly inside batch response, one for\n *     each error sub-response.\n *\n * - Asynchronous operations. If an API call embeds asynchronous operation\n *     results in its response, the status of those operations should be\n *     represented directly using the `Status` message.\n *\n * - Logging. If some API errors are stored in logs, the message `Status` could\n *     be used directly after any stripping needed for security/privacy reasons.\n *\n * @generated from message google.rpc.Status\n */\nexport class Status extends Message {\n    constructor(data) {\n        super();\n        /**\n         * The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].\n         *\n         * @generated from field: int32 code = 1;\n         */\n        this.code = 0;\n        /**\n         * A developer-facing error message, which should be in English. Any\n         * user-facing error message should be localized and sent in the\n         * [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.\n         *\n         * @generated from field: string message = 2;\n         */\n        this.message = \"\";\n        /**\n         * A list of messages that carry the error details.  There will be a\n         * common set of message types for APIs to use.\n         *\n         * @generated from field: repeated google.protobuf.Any details = 3;\n         */\n        this.details = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Status().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Status().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Status().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Status, a, b);\n    }\n}\nStatus.runtime = proto3;\nStatus.typeName = \"google.rpc.Status\";\nStatus.fields = proto3.util.newFieldList(() => [\n    { no: 1, name: \"code\", kind: \"scalar\", T: 5 /* ScalarType.INT32 */ },\n    { no: 2, name: \"message\", kind: \"scalar\", T: 9 /* ScalarType.STRING */ },\n    { no: 3, name: \"details\", kind: \"message\", T: Any, repeated: true },\n]);\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Any } from \"@bufbuild/protobuf\";\nimport { Status } from \"./gen/status_pb.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { decodeBinaryHeader, encodeBinaryHeader } from \"../http-headers.js\";\nimport { Code } from \"../code.js\";\nimport { headerGrpcMessage, headerGrpcStatus, headerStatusDetailsBin, } from \"./headers.js\";\n/**\n * The value of the Grpc-Status header or trailer in case of success.\n * Used by the gRPC and gRPC-web protocols.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const grpcStatusOk = \"0\";\n/**\n * Sets the fields \"grpc-status\" and \"grpc-message\" in the given\n * Headers object.\n * If an error is given and contains error details, the function\n * will also set the field \"grpc-status-details-bin\" with an encoded\n * google.rpc.Status message including the error details.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function setTrailerStatus(target, error) {\n    if (error) {\n        target.set(headerGrpcStatus, error.code.toString(10));\n        target.set(headerGrpcMessage, encodeURIComponent(error.rawMessage));\n        if (error.details.length > 0) {\n            const status = new Status({\n                code: error.code,\n                message: error.rawMessage,\n                details: error.details.map((value) => \"getType\" in value\n                    ? Any.pack(value)\n                    : new Any({\n                        typeUrl: `type.googleapis.com/${value.type}`,\n                        value: value.value,\n                    })),\n            });\n            target.set(headerStatusDetailsBin, encodeBinaryHeader(status));\n        }\n    }\n    else {\n        target.set(headerGrpcStatus, grpcStatusOk.toString());\n    }\n    return target;\n}\n/**\n * Find an error status in the given Headers object, which can be either\n * a trailer, or a header (as allowed for so-called trailers-only responses).\n * The field \"grpc-status-details-bin\" is inspected, and if not present,\n * the fields \"grpc-status\" and \"grpc-message\" are used.\n * Returns an error only if the gRPC status code is > 0.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function findTrailerError(headerOrTrailer) {\n    // TODO\n    // let code: Code;\n    // let message: string = \"\";\n    var _a;\n    // Prefer the protobuf-encoded data to the grpc-status header.\n    const statusBytes = headerOrTrailer.get(headerStatusDetailsBin);\n    if (statusBytes != null) {\n        const status = decodeBinaryHeader(statusBytes, Status);\n        if (status.code == 0) {\n            return undefined;\n        }\n        const error = new ConnectError(status.message, status.code, headerOrTrailer);\n        error.details = status.details.map((any) => ({\n            type: any.typeUrl.substring(any.typeUrl.lastIndexOf(\"/\") + 1),\n            value: any.value,\n        }));\n        return error;\n    }\n    const grpcStatus = headerOrTrailer.get(headerGrpcStatus);\n    if (grpcStatus != null) {\n        if (grpcStatus === grpcStatusOk) {\n            return undefined;\n        }\n        const code = parseInt(grpcStatus, 10);\n        if (code in Code) {\n            return new ConnectError(decodeURIComponent((_a = headerOrTrailer.get(headerGrpcMessage)) !== null && _a !== void 0 ? _a : \"\"), code, headerOrTrailer);\n        }\n        return new ConnectError(`invalid grpc-status: ${grpcStatus}`, Code.Internal, headerOrTrailer);\n    }\n    return undefined;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst contentTypeMatcherCacheSize = 1024;\n/**\n * Create a function that returns true if the given mime type is supported.\n * A mime type is supported when one of the regular expressions match.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function contentTypeMatcher(...supported) {\n    const cache = new Map();\n    const source = supported.reduce((previousValue, currentValue) => previousValue.concat(\"supported\" in currentValue ? currentValue.supported : currentValue), []);\n    function match(contentType) {\n        if (contentType === null || contentType.length == 0) {\n            return false;\n        }\n        const cached = cache.get(contentType);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const ok = source.some((re) => re.test(contentType));\n        if (cache.size < contentTypeMatcherCacheSize) {\n            cache.set(contentType, ok);\n        }\n        return ok;\n    }\n    match.supported = source;\n    return match;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a URL for the given RPC. This simply adds the qualified\n * service name, a slash, and the method name to the path of the given\n * baseUrl.\n *\n * For example, the baseUri https://example.com and method \"Say\" from\n * the service example.ElizaService results in:\n * https://example.com/example.ElizaService/Say\n *\n * This format is used by the protocols Connect, gRPC and Twirp.\n *\n * Note that this function also accepts a protocol-relative baseUrl.\n * If given an empty string or \"/\" as a baseUrl, it returns just the\n * path.\n */\nexport function createMethodUrl(baseUrl, service, method) {\n    const s = typeof service == \"string\" ? service : service.typeName;\n    const m = typeof method == \"string\" ? method : method.name;\n    return baseUrl.toString().replace(/\\/?$/, `/${s}/${m}`);\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Message } from \"@bufbuild/protobuf\";\n/**\n *  Takes a partial protobuf messages of the\n *  specified message type as input, and returns full instances.\n */\nexport function normalize(type, message) {\n    return message instanceof type\n        ? message\n        : new type(message);\n}\n/**\n * Takes an AsyncIterable of partial protobuf messages of the\n * specified message type as input, and yields full instances.\n */\nexport function normalizeIterable(messageType, input) {\n    function transform(result) {\n        if (result.done === true) {\n            return result;\n        }\n        return {\n            done: result.done,\n            value: normalize(messageType, result.value),\n        };\n    }\n    return {\n        [Symbol.asyncIterator]() {\n            const it = input[Symbol.asyncIterator]();\n            const res = {\n                next: () => it.next().then(transform),\n            };\n            if (it.throw !== undefined) {\n                res.throw = (e) => it.throw(e).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            if (it.return !== undefined) {\n                res.return = (v) => it.return(v).then(transform); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            }\n            return res;\n        },\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * applyInterceptors takes the given UnaryFn or ServerStreamingFn, and wraps\n * it with each of the given interceptors, returning a new UnaryFn or\n * ServerStreamingFn.\n */\nexport function applyInterceptors(next, interceptors) {\n    var _a;\n    return ((_a = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    (n, i) => i(n), next)) !== null && _a !== void 0 ? _a : next);\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n};\nimport { Message, MethodKind } from \"@bufbuild/protobuf\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { normalize, normalizeIterable } from \"./normalize.js\";\nimport { applyInterceptors } from \"../interceptor.js\";\n/**\n * Invoke a user-provided implementation of a unary RPC. Returns a normalized\n * output message.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport async function invokeUnaryImplementation(spec, context, input, interceptors) {\n    const anyFn = async (req) => {\n        return {\n            message: normalize(spec.method.O, await spec.impl(req.message, Object.assign(Object.assign({}, context), { service: req.service, method: req.method, requestHeader: req.header, values: req.contextValues, signal: req.signal }))),\n            stream: false,\n            service: req.service,\n            method: req.method,\n            header: context.responseHeader,\n            trailer: context.responseTrailer,\n        };\n    };\n    const next = applyInterceptors(anyFn, interceptors);\n    const { message } = await next({\n        init: {\n            method: context.requestMethod,\n        },\n        message: input,\n        url: context.url,\n        signal: context.signal,\n        service: spec.service,\n        method: spec.method,\n        header: context.requestHeader,\n        contextValues: context.values,\n        stream: false,\n    });\n    return message;\n}\n/**\n * Return an AsyncIterableTransform that invokes a user-provided implementation,\n * giving it input from an asynchronous iterable, and returning its output as an\n * asynchronous iterable.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformInvokeImplementation(spec, context, interceptors) {\n    switch (spec.kind) {\n        case MethodKind.Unary:\n            return function unary(input) {\n                return __asyncGenerator(this, arguments, function* unary_1() {\n                    const inputIt = input[Symbol.asyncIterator]();\n                    const input1 = yield __await(inputIt.next());\n                    if (input1.done === true) {\n                        throw new ConnectError(\"protocol error: missing input message for unary method\", Code.Unimplemented);\n                    }\n                    const anyFn = async (req) => {\n                        return {\n                            message: normalize(spec.method.O, await spec.impl(req.message, Object.assign(Object.assign({}, context), { service: req.service, method: req.method, requestHeader: req.header, values: req.contextValues, signal: req.signal }))),\n                            stream: false,\n                            service: req.service,\n                            method: req.method,\n                            header: context.responseHeader,\n                            trailer: context.responseTrailer,\n                        };\n                    };\n                    const next = applyInterceptors(anyFn, interceptors);\n                    const { message, header, trailer } = yield __await(next({\n                        init: {\n                            method: context.requestMethod,\n                        },\n                        message: input1.value,\n                        url: context.url,\n                        signal: context.signal,\n                        service: spec.service,\n                        method: spec.method,\n                        header: context.requestHeader,\n                        contextValues: context.values,\n                        stream: false,\n                    }));\n                    copyHeaders(header, context.responseHeader);\n                    copyHeaders(trailer, context.responseTrailer);\n                    yield yield __await(message);\n                    const input2 = yield __await(inputIt.next());\n                    if (input2.done !== true) {\n                        throw new ConnectError(\"protocol error: received extra input message for unary method\", Code.Unimplemented);\n                    }\n                });\n            };\n        case MethodKind.ServerStreaming: {\n            return function serverStreaming(input) {\n                return __asyncGenerator(this, arguments, function* serverStreaming_1() {\n                    const inputIt = input[Symbol.asyncIterator]();\n                    const input1 = yield __await(inputIt.next());\n                    if (input1.done === true) {\n                        throw new ConnectError(\"protocol error: missing input message for server-streaming method\", Code.Unimplemented);\n                    }\n                    const anyFn = async (req) => {\n                        return {\n                            message: normalizeIterable(spec.method.O, spec.impl(req.message, Object.assign(Object.assign({}, context), { service: req.service, method: req.method, requestHeader: req.header, values: req.contextValues, signal: req.signal }))),\n                            stream: true,\n                            service: req.service,\n                            method: req.method,\n                            header: context.responseHeader,\n                            trailer: context.responseTrailer,\n                        };\n                    };\n                    const next = applyInterceptors(anyFn, interceptors);\n                    const { message, header, trailer } = yield __await(next({\n                        init: {\n                            method: context.requestMethod,\n                        },\n                        message: input1.value,\n                        url: context.url,\n                        signal: context.signal,\n                        service: spec.service,\n                        method: spec.method,\n                        header: context.requestHeader,\n                        contextValues: context.values,\n                        stream: false,\n                    }));\n                    copyHeaders(header, context.responseHeader);\n                    copyHeaders(trailer, context.responseTrailer);\n                    yield __await(yield* __asyncDelegator(__asyncValues(message)));\n                    const input2 = yield __await(inputIt.next());\n                    if (input2.done !== true) {\n                        throw new ConnectError(\"protocol error: received extra input message for server-streaming method\", Code.Unimplemented);\n                    }\n                });\n            };\n        }\n        case MethodKind.ClientStreaming: {\n            return function clientStreaming(input) {\n                return __asyncGenerator(this, arguments, function* clientStreaming_1() {\n                    const anyFn = async (req) => {\n                        return {\n                            message: normalize(spec.method.O, await spec.impl(req.message, Object.assign(Object.assign({}, context), { service: req.service, method: req.method, requestHeader: req.header, values: req.contextValues, signal: req.signal }))),\n                            stream: false,\n                            service: req.service,\n                            method: req.method,\n                            header: context.responseHeader,\n                            trailer: context.responseTrailer,\n                        };\n                    };\n                    const next = applyInterceptors(anyFn, interceptors);\n                    const { message, header, trailer } = yield __await(next({\n                        init: {\n                            method: context.requestMethod,\n                        },\n                        message: input,\n                        url: context.url,\n                        signal: context.signal,\n                        service: spec.service,\n                        method: spec.method,\n                        header: context.requestHeader,\n                        contextValues: context.values,\n                        stream: true,\n                    }));\n                    copyHeaders(header, context.responseHeader);\n                    copyHeaders(trailer, context.responseTrailer);\n                    yield yield __await(message);\n                });\n            };\n        }\n        case MethodKind.BiDiStreaming:\n            return function biDiStreaming(input) {\n                return __asyncGenerator(this, arguments, function* biDiStreaming_1() {\n                    const anyFn = async (req) => {\n                        return {\n                            message: normalizeIterable(spec.method.O, spec.impl(req.message, Object.assign(Object.assign({}, context), { service: req.service, method: req.method, requestHeader: req.header, values: req.contextValues, signal: req.signal }))),\n                            stream: true,\n                            service: req.service,\n                            method: req.method,\n                            header: context.responseHeader,\n                            trailer: context.responseTrailer,\n                        };\n                    };\n                    const next = applyInterceptors(anyFn, interceptors);\n                    const { message, header, trailer } = yield __await(next({\n                        init: {\n                            method: context.requestMethod,\n                        },\n                        message: input,\n                        url: context.url,\n                        signal: context.signal,\n                        service: spec.service,\n                        method: spec.method,\n                        header: context.requestHeader,\n                        contextValues: context.values,\n                        stream: true,\n                    }));\n                    copyHeaders(header, context.responseHeader);\n                    copyHeaders(trailer, context.responseTrailer);\n                    yield __await(yield* __asyncDelegator(__asyncValues(message)));\n                });\n            };\n    }\n}\nfunction copyHeaders(from, to) {\n    if (from === to) {\n        return;\n    }\n    to.forEach((_, key) => {\n        to.delete(key);\n    });\n    from.forEach((value, key) => {\n        to.set(key, value);\n    });\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { assertReadMaxBytes, assertWriteMaxBytes } from \"./limit-io.js\";\n/**\n * Sets default JSON serialization options for connect-es.\n *\n * With standard protobuf JSON serialization, unknown JSON fields are\n * rejected by default. In connect-es, unknown JSON fields are ignored\n * by default.\n */\nexport function getJsonOptions(options) {\n    var _a;\n    const o = Object.assign({}, options);\n    (_a = o.ignoreUnknownFields) !== null && _a !== void 0 ? _a : (o.ignoreUnknownFields = true);\n    return o;\n}\n/**\n * Create an object that provides convenient access to request and response\n * message serialization for a given method.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createMethodSerializationLookup(method, binaryOptions, jsonOptions, limitOptions) {\n    const inputBinary = limitSerialization(createBinarySerialization(method.I, binaryOptions), limitOptions);\n    const inputJson = limitSerialization(createJsonSerialization(method.I, jsonOptions), limitOptions);\n    const outputBinary = limitSerialization(createBinarySerialization(method.O, binaryOptions), limitOptions);\n    const outputJson = limitSerialization(createJsonSerialization(method.O, jsonOptions), limitOptions);\n    return {\n        getI(useBinaryFormat) {\n            return useBinaryFormat ? inputBinary : inputJson;\n        },\n        getO(useBinaryFormat) {\n            return useBinaryFormat ? outputBinary : outputJson;\n        },\n    };\n}\n/**\n * Returns functions to normalize and serialize the input message\n * of an RPC, and to parse the output message of an RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {\n    const input = useBinaryFormat\n        ? createBinarySerialization(method.I, binaryOptions)\n        : createJsonSerialization(method.I, jsonOptions);\n    const output = useBinaryFormat\n        ? createBinarySerialization(method.O, binaryOptions)\n        : createJsonSerialization(method.O, jsonOptions);\n    return { parse: output.parse, serialize: input.serialize };\n}\n/**\n * Apply I/O limits to a Serialization object, returning a new object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function limitSerialization(serialization, limitOptions) {\n    return {\n        serialize(data) {\n            const bytes = serialization.serialize(data);\n            assertWriteMaxBytes(limitOptions.writeMaxBytes, bytes.byteLength);\n            return bytes;\n        },\n        parse(data) {\n            assertReadMaxBytes(limitOptions.readMaxBytes, data.byteLength, true);\n            return serialization.parse(data);\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf binary format.\n */\nexport function createBinarySerialization(messageType, options) {\n    return {\n        parse(data) {\n            try {\n                return messageType.fromBinary(data, options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`parse binary: ${m}`, Code.Internal);\n            }\n        },\n        serialize(data) {\n            try {\n                return data.toBinary(options);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`serialize binary: ${m}`, Code.Internal);\n            }\n        },\n    };\n}\n/**\n * Creates a Serialization object for serializing the given protobuf message\n * with the protobuf canonical JSON encoding.\n *\n * By default, unknown fields are ignored.\n */\nexport function createJsonSerialization(messageType, options) {\n    var _a, _b;\n    const textEncoder = (_a = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a !== void 0 ? _a : new TextEncoder();\n    const textDecoder = (_b = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b !== void 0 ? _b : new TextDecoder();\n    const o = getJsonOptions(options);\n    return {\n        parse(data) {\n            try {\n                const json = textDecoder.decode(data);\n                return messageType.fromJsonString(json, o);\n            }\n            catch (e) {\n                throw ConnectError.from(e, Code.InvalidArgument);\n            }\n        },\n        serialize(data) {\n            try {\n                const json = data.toJsonString(o);\n                return textEncoder.encode(json);\n            }\n            catch (e) {\n                throw ConnectError.from(e, Code.Internal);\n            }\n        },\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that the given UniversalServerRequest has a byte stream body, not\n * a JSON value.\n *\n * We accept a JSON object or a byte stream in server requests.\n * In practice, only Connect unary handlers will receive a parse\n * JSON object. Other call-sites can use this assertion to narrow\n * the union type. A failure in such a call-sites indicates that\n * the contract between a server framework and the connect-node \\\n * handler is broken.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function assertByteStreamRequest(req) {\n    if (typeof req.body == \"object\" &&\n        req.body !== null &&\n        Symbol.asyncIterator in req.body) {\n        return;\n    }\n    throw new Error(\"byte stream required, but received JSON\");\n}\n/**\n * HTTP 200 OK\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const uResponseOk = {\n    status: 200,\n};\n/**\n * HTTP 404 Not Found\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const uResponseNotFound = {\n    status: 404,\n};\n/**\n * HTTP 415 Unsupported Media Type\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const uResponseUnsupportedMediaType = {\n    status: 415,\n};\n/**\n * HTTP 405 Method Not Allowed\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const uResponseMethodNotAllowed = {\n    status: 405,\n};\n/**\n * HTTP 505 Version Not Supported\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const uResponseVersionNotSupported = {\n    status: 505,\n};\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { MethodKind } from \"@bufbuild/protobuf\";\nimport { uResponseMethodNotAllowed, uResponseUnsupportedMediaType, uResponseVersionNotSupported, } from \"./universal.js\";\nimport { contentTypeMatcher } from \"./content-type-matcher.js\";\nimport { validateReadWriteMaxBytes } from \"./limit-io.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * Asserts that the options are within sane limits, and returns default values\n * where no value is provided.\n *\n * Note that this function does not set default values for `acceptCompression`.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateUniversalHandlerOptions(opt) {\n    var _a, _b, _c;\n    opt !== null && opt !== void 0 ? opt : (opt = {});\n    const acceptCompression = opt.acceptCompression\n        ? [...opt.acceptCompression]\n        : [];\n    const requireConnectProtocolHeader = (_a = opt.requireConnectProtocolHeader) !== null && _a !== void 0 ? _a : false;\n    const maxTimeoutMs = (_b = opt.maxTimeoutMs) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER;\n    return Object.assign(Object.assign({ acceptCompression }, validateReadWriteMaxBytes(opt.readMaxBytes, opt.writeMaxBytes, opt.compressMinBytes)), { jsonOptions: opt.jsonOptions, binaryOptions: opt.binaryOptions, maxTimeoutMs, shutdownSignal: opt.shutdownSignal, requireConnectProtocolHeader, interceptors: (_c = opt.interceptors) !== null && _c !== void 0 ? _c : [] });\n}\n/**\n * For the given service implementation, return a universal handler for each\n * RPC. The handler serves the given protocols.\n *\n * At least one protocol is required.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createUniversalServiceHandlers(spec, protocols) {\n    return Object.entries(spec.methods).map(([, implSpec]) => createUniversalMethodHandler(implSpec, protocols));\n}\n/**\n * Return a universal handler for the given RPC implementation.\n * The handler serves the given protocols.\n *\n * At least one protocol is required.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createUniversalMethodHandler(spec, protocols) {\n    return negotiateProtocol(protocols.map((f) => f(spec)));\n}\n/**\n * Create a universal handler that negotiates the protocol.\n *\n * This functions takes one or more handlers - all for the same RPC, but for\n * different protocols - and returns a single handler that looks at the\n * Content-Type header and the HTTP verb of the incoming request to select\n * the appropriate protocol-specific handler.\n *\n * Raises an error if no protocol handlers were provided, or if they do not\n * handle exactly the same RPC.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function negotiateProtocol(protocolHandlers) {\n    if (protocolHandlers.length == 0) {\n        throw new ConnectError(\"at least one protocol is required\", Code.Internal);\n    }\n    const service = protocolHandlers[0].service;\n    const method = protocolHandlers[0].method;\n    const requestPath = protocolHandlers[0].requestPath;\n    if (protocolHandlers.some((h) => h.service !== service || h.method !== method)) {\n        throw new ConnectError(\"cannot negotiate protocol for different RPCs\", Code.Internal);\n    }\n    if (protocolHandlers.some((h) => h.requestPath !== requestPath)) {\n        throw new ConnectError(\"cannot negotiate protocol for different requestPaths\", Code.Internal);\n    }\n    async function protocolNegotiatingHandler(request) {\n        var _a;\n        if (method.kind == MethodKind.BiDiStreaming &&\n            request.httpVersion.startsWith(\"1.\")) {\n            return Object.assign(Object.assign({}, uResponseVersionNotSupported), { \n                // Clients coded to expect full-duplex connections may hang if they've\n                // mistakenly negotiated HTTP/1.1. To unblock them, we must close the\n                // underlying TCP connection.\n                header: new Headers({ Connection: \"close\" }) });\n        }\n        const contentType = (_a = request.header.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"\";\n        const matchingMethod = protocolHandlers.filter((h) => h.allowedMethods.includes(request.method));\n        if (matchingMethod.length == 0) {\n            return uResponseMethodNotAllowed;\n        }\n        // If Content-Type is unset but only one handler matches, use it.\n        if (matchingMethod.length == 1 && contentType === \"\") {\n            const onlyMatch = matchingMethod[0];\n            return onlyMatch(request);\n        }\n        const matchingContentTypes = matchingMethod.filter((h) => h.supportedContentType(contentType));\n        if (matchingContentTypes.length == 0) {\n            return uResponseUnsupportedMediaType;\n        }\n        const firstMatch = matchingContentTypes[0];\n        return firstMatch(request);\n    }\n    return Object.assign(protocolNegotiatingHandler, {\n        service,\n        method,\n        requestPath,\n        supportedContentType: contentTypeMatcher(...protocolHandlers.map((h) => h.supportedContentType)),\n        protocolNames: protocolHandlers\n            .flatMap((h) => h.protocolNames)\n            .filter((value, index, array) => array.indexOf(value) === index),\n        allowedMethods: protocolHandlers\n            .flatMap((h) => h.allowedMethods)\n            .filter((value, index, array) => array.indexOf(value) === index),\n    });\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { createHandlerContext } from \"../implementation.js\";\nimport { createTrailerSerialization, trailerFlag } from \"./trailer.js\";\nimport { headerAcceptEncoding, headerContentType, headerEncoding, headerGrpcStatus, headerTimeout, } from \"./headers.js\";\nimport { contentTypeJson, contentTypeProto, contentTypeRegExp, parseContentType, } from \"./content-type.js\";\nimport { parseTimeout } from \"../protocol-grpc/parse-timeout.js\";\nimport { grpcStatusOk, setTrailerStatus, } from \"../protocol-grpc/trailer-status.js\";\nimport { pipe, transformPrepend, transformSplitEnvelope, transformDecompressEnvelope, transformParseEnvelope, transformSerializeEnvelope, transformCatchFinally, transformCompressEnvelope, transformJoinEnvelopes, untilFirst, } from \"../protocol/async-iterable.js\";\nimport { compressionNegotiate } from \"../protocol/compression.js\";\nimport { contentTypeMatcher } from \"../protocol/content-type-matcher.js\";\nimport { createMethodUrl } from \"../protocol/create-method-url.js\";\nimport { transformInvokeImplementation } from \"../protocol/invoke-implementation.js\";\nimport { createMethodSerializationLookup } from \"../protocol/serialization.js\";\nimport { validateUniversalHandlerOptions } from \"../protocol/universal-handler.js\";\nimport { assertByteStreamRequest, uResponseUnsupportedMediaType, uResponseMethodNotAllowed, uResponseOk, } from \"../protocol/universal.js\";\nconst protocolName = \"grpc-web\";\nconst methodPost = \"POST\";\n/**\n * Create a factory that creates gRPC-web handlers.\n */\nexport function createHandlerFactory(options) {\n    const opt = validateUniversalHandlerOptions(options);\n    const trailerSerialization = createTrailerSerialization();\n    function fact(spec) {\n        const h = createHandler(opt, trailerSerialization, spec);\n        return Object.assign(h, {\n            protocolNames: [protocolName],\n            allowedMethods: [methodPost],\n            supportedContentType: contentTypeMatcher(contentTypeRegExp),\n            requestPath: createMethodUrl(\"/\", spec.service, spec.method),\n            service: spec.service,\n            method: spec.method,\n        });\n    }\n    fact.protocolName = protocolName;\n    return fact;\n}\nfunction createHandler(opt, trailerSerialization, spec) {\n    const serialization = createMethodSerializationLookup(spec.method, opt.binaryOptions, opt.jsonOptions, opt);\n    return async function handle(req) {\n        assertByteStreamRequest(req);\n        const type = parseContentType(req.header.get(headerContentType));\n        if (type == undefined || type.text) {\n            return uResponseUnsupportedMediaType;\n        }\n        if (req.method !== methodPost) {\n            return uResponseMethodNotAllowed;\n        }\n        const timeout = parseTimeout(req.header.get(headerTimeout), opt.maxTimeoutMs);\n        const context = createHandlerContext(Object.assign(Object.assign({}, spec), { requestMethod: req.method, protocolName, timeoutMs: timeout.timeoutMs, shutdownSignal: opt.shutdownSignal, requestSignal: req.signal, requestHeader: req.header, url: req.url, responseHeader: {\n                [headerContentType]: type.binary ? contentTypeProto : contentTypeJson,\n            }, responseTrailer: {\n                [headerGrpcStatus]: grpcStatusOk,\n            }, contextValues: req.contextValues }));\n        const compression = compressionNegotiate(opt.acceptCompression, req.header.get(headerEncoding), req.header.get(headerAcceptEncoding), headerAcceptEncoding);\n        if (compression.response) {\n            context.responseHeader.set(headerEncoding, compression.response.name);\n        }\n        // We split the pipeline into two parts: The request iterator, and the\n        // response iterator. We do this because the request iterator is responsible\n        // for parsing the request body, and we don't want write errors of the response\n        // iterator to affect the request iterator.\n        const inputIt = pipe(req.body, transformPrepend(() => {\n            // raise compression error to serialize it as a trailer status\n            if (compression.error)\n                throw compression.error;\n            // raise timeout parsing error to serialize it as a trailer status\n            if (timeout.error)\n                throw timeout.error;\n            return undefined;\n        }), transformSplitEnvelope(opt.readMaxBytes), transformDecompressEnvelope(compression.request, opt.readMaxBytes), transformParseEnvelope(serialization.getI(type.binary), trailerFlag));\n        const it = transformInvokeImplementation(spec, context, opt.interceptors)(inputIt)[Symbol.asyncIterator]();\n        const outputIt = pipe(\n        // We wrap the iterator in an async iterator to ensure that the\n        // abort signal is aborted when the iterator is done.\n        {\n            [Symbol.asyncIterator]() {\n                return {\n                    next: () => it.next(),\n                    throw: (e) => {\n                        var _a, _b;\n                        context.abort(e);\n                        return (_b = (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, e)) !== null && _b !== void 0 ? _b : Promise.reject({ done: true });\n                    },\n                    return: (v) => {\n                        var _a, _b;\n                        context.abort();\n                        return ((_b = (_a = it.return) === null || _a === void 0 ? void 0 : _a.call(it, v)) !== null && _b !== void 0 ? _b : Promise.resolve({ done: true, value: v }));\n                    },\n                };\n            },\n        }, transformSerializeEnvelope(serialization.getO(type.binary)), transformCatchFinally((e) => {\n            context.abort();\n            if (e instanceof ConnectError) {\n                setTrailerStatus(context.responseTrailer, e);\n            }\n            else if (e !== undefined) {\n                setTrailerStatus(context.responseTrailer, new ConnectError(\"internal error\", Code.Internal, undefined, undefined, e));\n            }\n            return {\n                flags: trailerFlag,\n                data: trailerSerialization.serialize(context.responseTrailer),\n            };\n        }), transformCompressEnvelope(compression.response, opt.compressMinBytes), transformJoinEnvelopes(), { propagateDownStreamError: true });\n        return Object.assign(Object.assign({}, uResponseOk), { \n            // We wait for the first response body bytes before resolving, so that\n            // implementations have a chance to add headers before an adapter commits\n            // them to the wire.\n            body: await untilFirst(outputIt), header: context.responseHeader });\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid gRPC Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const contentTypeRegExp = /^application\\/grpc(?:\\+(?:(json)(?:; ?charset=utf-?8)?|proto))?$/i;\nexport const contentTypeProto = \"application/grpc+proto\";\nexport const contentTypeJson = \"application/grpc+json\";\n/**\n * Parse a gRPC Content-Type header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const binary = !match[1];\n    return { binary };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { createHandlerContext } from \"../implementation.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { contentTypeJson, contentTypeProto, contentTypeRegExp, parseContentType, } from \"./content-type.js\";\nimport { headerAcceptEncoding, headerContentType, headerEncoding, headerGrpcStatus, headerTimeout, } from \"./headers.js\";\nimport { grpcStatusOk, setTrailerStatus } from \"./trailer-status.js\";\nimport { parseTimeout } from \"./parse-timeout.js\";\nimport { pipe, transformPrepend, transformSplitEnvelope, transformDecompressEnvelope, transformParseEnvelope, transformSerializeEnvelope, transformCompressEnvelope, transformJoinEnvelopes, transformCatchFinally, untilFirst, } from \"../protocol/async-iterable.js\";\nimport { compressionNegotiate } from \"../protocol/compression.js\";\nimport { contentTypeMatcher } from \"../protocol/content-type-matcher.js\";\nimport { createMethodUrl } from \"../protocol/create-method-url.js\";\nimport { transformInvokeImplementation } from \"../protocol/invoke-implementation.js\";\nimport { createMethodSerializationLookup } from \"../protocol/serialization.js\";\nimport { validateUniversalHandlerOptions } from \"../protocol/universal-handler.js\";\nimport { assertByteStreamRequest, uResponseUnsupportedMediaType, uResponseMethodNotAllowed, uResponseOk, } from \"../protocol/universal.js\";\nconst protocolName = \"grpc\";\nconst methodPost = \"POST\";\n/**\n * Create a factory that creates gRPC handlers.\n */\nexport function createHandlerFactory(options) {\n    const opt = validateUniversalHandlerOptions(options);\n    function fact(spec) {\n        const h = createHandler(opt, spec);\n        return Object.assign(h, {\n            protocolNames: [protocolName],\n            allowedMethods: [methodPost],\n            supportedContentType: contentTypeMatcher(contentTypeRegExp),\n            requestPath: createMethodUrl(\"/\", spec.service, spec.method),\n            service: spec.service,\n            method: spec.method,\n        });\n    }\n    fact.protocolName = protocolName;\n    return fact;\n}\nfunction createHandler(opt, spec) {\n    const serialization = createMethodSerializationLookup(spec.method, opt.binaryOptions, opt.jsonOptions, opt);\n    return async function handle(req) {\n        assertByteStreamRequest(req);\n        const type = parseContentType(req.header.get(headerContentType));\n        if (type == undefined) {\n            return uResponseUnsupportedMediaType;\n        }\n        if (req.method !== methodPost) {\n            return uResponseMethodNotAllowed;\n        }\n        const timeout = parseTimeout(req.header.get(headerTimeout), opt.maxTimeoutMs);\n        const context = createHandlerContext(Object.assign(Object.assign({}, spec), { requestMethod: req.method, protocolName, timeoutMs: timeout.timeoutMs, shutdownSignal: opt.shutdownSignal, requestSignal: req.signal, requestHeader: req.header, url: req.url, responseHeader: {\n                [headerContentType]: type.binary ? contentTypeProto : contentTypeJson,\n            }, responseTrailer: {\n                [headerGrpcStatus]: grpcStatusOk,\n            }, contextValues: req.contextValues }));\n        const compression = compressionNegotiate(opt.acceptCompression, req.header.get(headerEncoding), req.header.get(headerAcceptEncoding), headerAcceptEncoding);\n        if (compression.response) {\n            context.responseHeader.set(headerEncoding, compression.response.name);\n        }\n        // We split the pipeline into two parts: The request iterator, and the\n        // response iterator. We do this because the request iterator is responsible\n        // for parsing the request body, and we don't want write errors of the response\n        // iterator to affect the request iterator.\n        const inputIt = pipe(req.body, transformPrepend(() => {\n            // raise compression error to serialize it as a trailer status\n            if (compression.error)\n                throw compression.error;\n            // raise timeout parsing error to serialize it as a trailer status\n            if (timeout.error)\n                throw timeout.error;\n            return undefined;\n        }), transformSplitEnvelope(opt.readMaxBytes), transformDecompressEnvelope(compression.request, opt.readMaxBytes), transformParseEnvelope(serialization.getI(type.binary)));\n        const it = transformInvokeImplementation(spec, context, opt.interceptors)(inputIt)[Symbol.asyncIterator]();\n        const outputIt = pipe(\n        // We wrap the iterator in an async iterator to ensure that the\n        // abort signal is aborted when the iterator is done.\n        {\n            [Symbol.asyncIterator]() {\n                return {\n                    next: () => it.next(),\n                    throw: (e) => {\n                        var _a, _b;\n                        context.abort(e);\n                        return (_b = (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, e)) !== null && _b !== void 0 ? _b : Promise.reject({ done: true });\n                    },\n                    return: (v) => {\n                        var _a, _b;\n                        context.abort();\n                        return ((_b = (_a = it.return) === null || _a === void 0 ? void 0 : _a.call(it, v)) !== null && _b !== void 0 ? _b : Promise.resolve({ done: true, value: v }));\n                    },\n                };\n            },\n        }, transformSerializeEnvelope(serialization.getO(type.binary)), transformCompressEnvelope(compression.response, opt.compressMinBytes), transformJoinEnvelopes(), transformCatchFinally((e) => {\n            context.abort();\n            if (e instanceof ConnectError) {\n                setTrailerStatus(context.responseTrailer, e);\n            }\n            else if (e !== undefined) {\n                setTrailerStatus(context.responseTrailer, new ConnectError(\"internal error\", Code.Internal, undefined, undefined, e));\n            }\n        }), { propagateDownStreamError: true });\n        return Object.assign(Object.assign({}, uResponseOk), { \n            // We wait for the first response body bytes before resolving, so that\n            // implementations have a chance to add headers before an adapter commits\n            // them to the wire.\n            body: await untilFirst(outputIt), header: context.responseHeader, trailer: context.responseTrailer });\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Regular Expression that matches any valid Connect Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const contentTypeRegExp = /^application\\/(connect\\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i;\n/**\n * Regular Expression that matches a Connect unary Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const contentTypeUnaryRegExp = /^application\\/(?:json(?:; ?charset=utf-?8)?|proto)$/i;\n/**\n * Regular Expression that matches a Connect streaming Content-Type header value.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const contentTypeStreamRegExp = /^application\\/connect\\+?(?:json(?:; ?charset=utf-?8)?|proto)$/i;\nexport const contentTypeUnaryProto = \"application/proto\";\nexport const contentTypeUnaryJson = \"application/json\";\nexport const contentTypeStreamProto = \"application/connect+proto\";\nexport const contentTypeStreamJson = \"application/connect+json\";\nconst encodingProto = \"proto\";\nconst encodingJson = \"json\";\n/**\n * Parse a Connect Content-Type header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseContentType(contentType) {\n    const match = contentType === null || contentType === void 0 ? void 0 : contentType.match(contentTypeRegExp);\n    if (!match) {\n        return undefined;\n    }\n    const stream = !!match[1];\n    const binary = !!match[3];\n    return { stream, binary };\n}\n/**\n * Parse a Connect Get encoding query parameter.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseEncodingQuery(encoding) {\n    switch (encoding) {\n        case encodingProto:\n            return { stream: false, binary: true };\n        case encodingJson:\n            return { stream: false, binary: false };\n        default:\n            return undefined;\n    }\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { protoBase64 } from \"@bufbuild/protobuf\";\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { codeFromString, codeToString } from \"./code-string.js\";\n/**\n * Parse a Connect error from a JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function errorFromJson(jsonValue, metadata, fallback) {\n    var _a;\n    if (metadata) {\n        new Headers(metadata).forEach((value, key) => fallback.metadata.append(key, value));\n    }\n    if (typeof jsonValue !== \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw fallback;\n    }\n    let code = fallback.code;\n    if (\"code\" in jsonValue && typeof jsonValue.code === \"string\") {\n        code = (_a = codeFromString(jsonValue.code)) !== null && _a !== void 0 ? _a : code;\n    }\n    const message = jsonValue.message;\n    if (message != null && typeof message !== \"string\") {\n        throw fallback;\n    }\n    const error = new ConnectError(message !== null && message !== void 0 ? message : \"\", code, metadata);\n    if (\"details\" in jsonValue && Array.isArray(jsonValue.details)) {\n        for (const detail of jsonValue.details) {\n            if (detail === null ||\n                typeof detail != \"object\" ||\n                Array.isArray(detail) ||\n                typeof detail.type != \"string\" ||\n                typeof detail.value != \"string\") {\n                throw fallback;\n            }\n            try {\n                error.details.push({\n                    type: detail.type,\n                    value: protoBase64.dec(detail.value),\n                    debug: detail.debug,\n                });\n            }\n            catch (e) {\n                throw fallback;\n            }\n        }\n    }\n    return error;\n}\n/**\n * Parse a Connect error from a serialized JSON value.\n * Will return a ConnectError, and throw the provided fallback if parsing failed.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function errorFromJsonBytes(bytes, metadata, fallback) {\n    let jsonValue;\n    try {\n        jsonValue = JSON.parse(new TextDecoder().decode(bytes));\n    }\n    catch (e) {\n        throw fallback;\n    }\n    return errorFromJson(jsonValue, metadata, fallback);\n}\n/**\n * Serialize the given error to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation in the \"debug\" key if the detail uses\n * google.protobuf.Any. If serialization of the \"debug\" value fails, it\n * is silently disregarded.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function errorToJson(error, jsonWriteOptions) {\n    const o = {\n        code: codeToString(error.code),\n    };\n    if (error.rawMessage.length > 0) {\n        o.message = error.rawMessage;\n    }\n    if (error.details.length > 0) {\n        o.details = error.details\n            .map((value) => {\n            if (\"getType\" in value) {\n                const i = {\n                    type: value.getType().typeName,\n                    value: value.toBinary(),\n                };\n                try {\n                    i.debug = value.toJson(jsonWriteOptions);\n                }\n                catch (e) {\n                    // We deliberately ignore errors that may occur when serializing\n                    // a message to JSON (the message contains an Any).\n                    // The rationale is that we are only trying to provide optional\n                    // debug information.\n                }\n                return i;\n            }\n            return value;\n        })\n            .map((_a) => {\n            var { value } = _a, rest = __rest(_a, [\"value\"]);\n            return (Object.assign(Object.assign({}, rest), { value: protoBase64.enc(value).replace(/=+$/, \"\") }));\n        });\n    }\n    return o;\n}\n/**\n * Serialize the given error to JSON. This calls errorToJson(), but stringifies\n * the result, and converts it into a UInt8Array.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function errorToJsonBytes(error, jsonWriteOptions) {\n    const textEncoder = new TextEncoder();\n    try {\n        const jsonObject = errorToJson(error, jsonWriteOptions);\n        const jsonString = JSON.stringify(jsonObject);\n        return textEncoder.encode(jsonString);\n    }\n    catch (e) {\n        const m = e instanceof Error ? e.message : String(e);\n        throw new ConnectError(`failed to serialize Connect Error: ${m}`, Code.Internal);\n    }\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { errorFromJson, errorToJson } from \"./error-json.js\";\nimport { appendHeaders } from \"../http-headers.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * endStreamFlag indicates that the data in a EnvelopedMessage\n * is a EndStreamResponse of the Connect protocol.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const endStreamFlag = 0b00000010;\n/**\n * Parse an EndStreamResponse of the Connect protocol.\n * Throws a ConnectError on malformed input.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function endStreamFromJson(data) {\n    const parseErr = new ConnectError(\"invalid end stream\", Code.Unknown);\n    let jsonValue;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        jsonValue = JSON.parse(typeof data == \"string\" ? data : new TextDecoder().decode(data));\n    }\n    catch (e) {\n        throw parseErr;\n    }\n    if (typeof jsonValue != \"object\" ||\n        jsonValue == null ||\n        Array.isArray(jsonValue)) {\n        throw parseErr;\n    }\n    const metadata = new Headers();\n    if (\"metadata\" in jsonValue) {\n        if (typeof jsonValue.metadata != \"object\" ||\n            jsonValue.metadata == null ||\n            Array.isArray(jsonValue.metadata)) {\n            throw parseErr;\n        }\n        for (const [key, values] of Object.entries(jsonValue.metadata)) {\n            if (!Array.isArray(values) ||\n                values.some((value) => typeof value != \"string\")) {\n                throw parseErr;\n            }\n            for (const value of values) {\n                metadata.append(key, value);\n            }\n        }\n    }\n    const error = \"error\" in jsonValue && jsonValue.error != null\n        ? errorFromJson(jsonValue.error, metadata, parseErr)\n        : undefined;\n    return { metadata, error };\n}\n/**\n * Serialize the given EndStreamResponse to JSON.\n *\n * The JSON serialization options are required to produce the optional\n * human-readable representation of error details if the detail uses\n * google.protobuf.Any.\n *\n * See https://connectrpc.com/docs/protocol#error-end-stream\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function endStreamToJson(metadata, error, jsonWriteOptions) {\n    const es = {};\n    if (error !== undefined) {\n        es.error = errorToJson(error, jsonWriteOptions);\n        metadata = appendHeaders(metadata, error.metadata);\n    }\n    let hasMetadata = false;\n    const md = {};\n    metadata.forEach((value, key) => {\n        hasMetadata = true;\n        md[key] = [value];\n    });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (hasMetadata) {\n        es.metadata = md;\n    }\n    return es;\n}\n/**\n * Create a Serialization object that serializes a Connect EndStreamResponse.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function createEndStreamSerialization(options) {\n    const textEncoder = new TextEncoder();\n    return {\n        serialize(data) {\n            try {\n                const jsonObject = endStreamToJson(data.metadata, data.error, options);\n                const jsonString = JSON.stringify(jsonObject);\n                return textEncoder.encode(jsonString);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`failed to serialize EndStreamResponse: ${m}`, Code.Internal);\n            }\n        },\n        parse(data) {\n            try {\n                return endStreamFromJson(data);\n            }\n            catch (e) {\n                const m = e instanceof Error ? e.message : String(e);\n                throw new ConnectError(`failed to parse EndStreamResponse: ${m}`, Code.InvalidArgument);\n            }\n        },\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nexport const headerContentType = \"Content-Type\";\nexport const headerUnaryContentLength = \"Content-Length\";\nexport const headerUnaryEncoding = \"Content-Encoding\";\nexport const headerStreamEncoding = \"Connect-Content-Encoding\";\nexport const headerUnaryAcceptEncoding = \"Accept-Encoding\";\nexport const headerStreamAcceptEncoding = \"Connect-Accept-Encoding\";\nexport const headerTimeout = \"Connect-Timeout-Ms\";\nexport const headerProtocolVersion = \"Connect-Protocol-Version\";\nexport const headerUserAgent = \"User-Agent\";\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\n/**\n * Determine the Connect error code for the given HTTP status code.\n * See https://connectrpc.com/docs/protocol/#http-to-error-code\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return Code.Internal;\n        case 401: // Unauthorized\n            return Code.Unauthenticated;\n        case 403: // Forbidden\n            return Code.PermissionDenied;\n        case 404: // Not Found\n            return Code.Unimplemented;\n        case 429: // Too Many Requests\n            return Code.Unavailable;\n        case 502: // Bad Gateway\n            return Code.Unavailable;\n        case 503: // Service Unavailable\n            return Code.Unavailable;\n        case 504: // Gateway Timeout\n            return Code.Unavailable;\n        default:\n            return Code.Unknown;\n    }\n}\n/**\n * Returns a HTTP status code for the given Connect code.\n * See https://connectrpc.com/docs/protocol#error-codes\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeToHttpStatus(code) {\n    switch (code) {\n        case Code.Canceled:\n            return 499; // Client Closed Request\n        case Code.Unknown:\n            return 500; // Internal Server Error\n        case Code.InvalidArgument:\n            return 400; // Bad Request\n        case Code.DeadlineExceeded:\n            return 504; // Gateway Timeout\n        case Code.NotFound:\n            return 404; // Not Found\n        case Code.AlreadyExists:\n            return 409; // Conflict\n        case Code.PermissionDenied:\n            return 403; // Forbidden\n        case Code.ResourceExhausted:\n            return 429; // Too Many Requests\n        case Code.FailedPrecondition:\n            return 400; // Bad Request\n        case Code.Aborted:\n            return 409; // Conflict\n        case Code.OutOfRange:\n            return 400; // Bad Request\n        case Code.Unimplemented:\n            return 501; // Not Implemented\n        case Code.Internal:\n            return 500; // Internal Server Error\n        case Code.Unavailable:\n            return 503; // Service Unavailable\n        case Code.DataLoss:\n            return 500; // Internal Server Error\n        case Code.Unauthenticated:\n            return 401; // Unauthorized\n        default:\n            return 500; // same as CodeUnknown\n    }\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\n/**\n * Parse a Connect Timeout (Deadline) header.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function parseTimeout(value, maxTimeoutMs) {\n    if (value === null) {\n        return {};\n    }\n    const results = /^\\d{1,10}$/.exec(value);\n    if (results === null) {\n        return {\n            error: new ConnectError(`protocol error: invalid connect timeout value: ${value}`, Code.InvalidArgument),\n        };\n    }\n    const timeoutMs = parseInt(results[0]);\n    if (timeoutMs > maxTimeoutMs) {\n        return {\n            timeoutMs: timeoutMs,\n            error: new ConnectError(`timeout ${timeoutMs}ms must be <= ${maxTimeoutMs}`, Code.InvalidArgument),\n        };\n    }\n    return {\n        timeoutMs: parseInt(results[0]),\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nexport const paramConnectVersion = \"connect\";\nexport const paramEncoding = \"encoding\";\nexport const paramCompression = \"compression\";\nexport const paramBase64 = \"base64\";\nexport const paramMessage = \"message\";\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function demuxes headers and trailers into two separate Headers\n * objects.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function trailerDemux(header) {\n    const h = new Headers(), t = new Headers();\n    header.forEach((value, key) => {\n        if (key.toLowerCase().startsWith(\"trailer-\")) {\n            t.append(key.substring(8), value);\n        }\n        else {\n            h.append(key, value);\n        }\n    });\n    return [h, t];\n}\n/**\n * In unary RPCs, Connect transports trailing metadata as response header\n * fields, prefixed with \"trailer-\".\n *\n * This function muxes a header and a trailer into a single Headers object.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function trailerMux(header, trailer) {\n    const h = new Headers(header);\n    trailer.forEach((value, key) => {\n        h.append(`trailer-${key}`, value);\n    });\n    return h;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { headerProtocolVersion } from \"./headers.js\";\nimport { paramConnectVersion } from \"./query-params.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\n/**\n * The only know value for the header Connect-Protocol-Version.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport const protocolVersion = \"1\";\n/**\n * Requires the Connect-Protocol-Version header to be present with the expected\n * value. Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requireProtocolVersionHeader(requestHeader) {\n    const v = requestHeader.get(headerProtocolVersion);\n    if (v === null) {\n        throw new ConnectError(`missing required header: set ${headerProtocolVersion} to \"${protocolVersion}\"`, Code.InvalidArgument);\n    }\n    else if (v !== protocolVersion) {\n        throw new ConnectError(`${headerProtocolVersion} must be \"${protocolVersion}\": got \"${v}\"`, Code.InvalidArgument);\n    }\n}\n/**\n * Requires the connect query parameter to be present with the expected value.\n * Raises a ConnectError with Code.InvalidArgument otherwise.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requireProtocolVersionParam(queryParams) {\n    const v = queryParams.get(paramConnectVersion);\n    if (v === null) {\n        throw new ConnectError(`missing required parameter: set ${paramConnectVersion} to \"v${protocolVersion}\"`, Code.InvalidArgument);\n    }\n    else if (v !== `v${protocolVersion}`) {\n        throw new ConnectError(`${paramConnectVersion} must be \"v${protocolVersion}\": got \"${v}\"`, Code.InvalidArgument);\n    }\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Message, MethodIdempotency, MethodKind, protoBase64, } from \"@bufbuild/protobuf\";\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { createHandlerContext } from \"../implementation.js\";\nimport { contentTypeStreamJson, contentTypeStreamProto, contentTypeStreamRegExp, contentTypeUnaryJson, contentTypeUnaryProto, contentTypeUnaryRegExp, parseContentType, parseEncodingQuery, } from \"./content-type.js\";\nimport { createEndStreamSerialization, endStreamFlag } from \"./end-stream.js\";\nimport { errorToJsonBytes } from \"./error-json.js\";\nimport { headerContentType, headerStreamAcceptEncoding, headerStreamEncoding, headerTimeout, headerUnaryAcceptEncoding, headerUnaryContentLength, headerUnaryEncoding, } from \"./headers.js\";\nimport { codeToHttpStatus } from \"./http-status.js\";\nimport { parseTimeout } from \"./parse-timeout.js\";\nimport { paramBase64, paramCompression, paramEncoding, paramMessage, } from \"./query-params.js\";\nimport { trailerMux } from \"./trailer-mux.js\";\nimport { requireProtocolVersionHeader, requireProtocolVersionParam, } from \"./version.js\";\nimport { compressionNegotiate } from \"../protocol/compression.js\";\nimport { createMethodSerializationLookup } from \"../protocol/serialization.js\";\nimport { validateUniversalHandlerOptions } from \"../protocol/universal-handler.js\";\nimport { assertByteStreamRequest, uResponseMethodNotAllowed, uResponseOk, uResponseUnsupportedMediaType, } from \"../protocol/universal.js\";\nimport { createAsyncIterable, pipe, readAllBytes, transformCatchFinally, transformCompressEnvelope, transformDecompressEnvelope, transformJoinEnvelopes, transformParseEnvelope, transformPrepend, transformSerializeEnvelope, transformSplitEnvelope, untilFirst, } from \"../protocol/async-iterable.js\";\nimport { contentTypeMatcher } from \"../protocol/content-type-matcher.js\";\nimport { createMethodUrl } from \"../protocol/create-method-url.js\";\nimport { invokeUnaryImplementation, transformInvokeImplementation, } from \"../protocol/invoke-implementation.js\";\nconst protocolName = \"connect\";\nconst methodPost = \"POST\";\nconst methodGet = \"GET\";\n/**\n * Create a factory that creates Connect handlers.\n */\nexport function createHandlerFactory(options) {\n    const opt = validateUniversalHandlerOptions(options);\n    const endStreamSerialization = createEndStreamSerialization(opt.jsonOptions);\n    function fact(spec) {\n        let h;\n        let contentTypeRegExp;\n        const serialization = createMethodSerializationLookup(spec.method, opt.binaryOptions, opt.jsonOptions, opt);\n        switch (spec.kind) {\n            case MethodKind.Unary:\n                contentTypeRegExp = contentTypeUnaryRegExp;\n                h = createUnaryHandler(opt, spec, serialization);\n                break;\n            default:\n                contentTypeRegExp = contentTypeStreamRegExp;\n                h = createStreamHandler(opt, spec, serialization, endStreamSerialization);\n                break;\n        }\n        const allowedMethods = [methodPost];\n        if (spec.method.idempotency === MethodIdempotency.NoSideEffects) {\n            allowedMethods.push(methodGet);\n        }\n        return Object.assign(h, {\n            protocolNames: [protocolName],\n            supportedContentType: contentTypeMatcher(contentTypeRegExp),\n            allowedMethods,\n            requestPath: createMethodUrl(\"/\", spec.service, spec.method),\n            service: spec.service,\n            method: spec.method,\n        });\n    }\n    fact.protocolName = protocolName;\n    return fact;\n}\nfunction createUnaryHandler(opt, spec, serialization) {\n    return async function handle(req) {\n        const isGet = req.method == methodGet;\n        if (isGet && spec.method.idempotency != MethodIdempotency.NoSideEffects) {\n            return uResponseMethodNotAllowed;\n        }\n        const queryParams = new URL(req.url).searchParams;\n        const compressionRequested = isGet\n            ? queryParams.get(paramCompression)\n            : req.header.get(headerUnaryEncoding);\n        const type = isGet\n            ? parseEncodingQuery(queryParams.get(paramEncoding))\n            : parseContentType(req.header.get(headerContentType));\n        if (type == undefined || type.stream) {\n            return uResponseUnsupportedMediaType;\n        }\n        const timeout = parseTimeout(req.header.get(headerTimeout), opt.maxTimeoutMs);\n        const context = createHandlerContext(Object.assign(Object.assign({}, spec), { requestMethod: req.method, protocolName, timeoutMs: timeout.timeoutMs, shutdownSignal: opt.shutdownSignal, requestSignal: req.signal, requestHeader: req.header, url: req.url, responseHeader: {\n                [headerContentType]: type.binary\n                    ? contentTypeUnaryProto\n                    : contentTypeUnaryJson,\n            }, contextValues: req.contextValues }));\n        const compression = compressionNegotiate(opt.acceptCompression, compressionRequested, req.header.get(headerUnaryAcceptEncoding), headerUnaryAcceptEncoding);\n        let status = uResponseOk.status;\n        let body;\n        try {\n            if (opt.requireConnectProtocolHeader) {\n                if (isGet) {\n                    requireProtocolVersionParam(queryParams);\n                }\n                else {\n                    requireProtocolVersionHeader(req.header);\n                }\n            }\n            // raise compression error to serialize it as a error response\n            if (compression.error) {\n                throw compression.error;\n            }\n            // raise timeout parsing error to serialize it as a trailer status\n            if (timeout.error) {\n                throw timeout.error;\n            }\n            let reqBody;\n            if (isGet) {\n                reqBody = await readUnaryMessageFromQuery(opt.readMaxBytes, compression.request, queryParams);\n            }\n            else {\n                reqBody = await readUnaryMessageFromBody(opt.readMaxBytes, compression.request, req);\n            }\n            const input = parseUnaryMessage(spec.method, type.binary, serialization, reqBody);\n            const output = await invokeUnaryImplementation(spec, context, input, opt.interceptors);\n            body = serialization.getO(type.binary).serialize(output);\n        }\n        catch (e) {\n            let error;\n            if (e instanceof ConnectError) {\n                error = e;\n            }\n            else {\n                error = new ConnectError(\"internal error\", Code.Internal, undefined, undefined, e);\n            }\n            status = codeToHttpStatus(error.code);\n            context.responseHeader.set(headerContentType, contentTypeUnaryJson);\n            error.metadata.forEach((value, key) => {\n                context.responseHeader.set(key, value);\n            });\n            body = errorToJsonBytes(error, opt.jsonOptions);\n        }\n        finally {\n            context.abort();\n        }\n        if (compression.response && body.byteLength >= opt.compressMinBytes) {\n            body = await compression.response.compress(body);\n            context.responseHeader.set(headerUnaryEncoding, compression.response.name);\n        }\n        const header = trailerMux(context.responseHeader, context.responseTrailer);\n        header.set(headerUnaryContentLength, body.byteLength.toString(10));\n        return {\n            status,\n            body: createAsyncIterable([body]),\n            header,\n        };\n    };\n}\nasync function readUnaryMessageFromBody(readMaxBytes, compression, request) {\n    if (typeof request.body == \"object\" &&\n        request.body !== null &&\n        Symbol.asyncIterator in request.body) {\n        let reqBytes = await readAllBytes(request.body, readMaxBytes, request.header.get(headerUnaryContentLength));\n        if (compression) {\n            reqBytes = await compression.decompress(reqBytes, readMaxBytes);\n        }\n        return reqBytes;\n    }\n    return request.body;\n}\nasync function readUnaryMessageFromQuery(readMaxBytes, compression, queryParams) {\n    var _a;\n    const base64 = queryParams.get(paramBase64);\n    const message = (_a = queryParams.get(paramMessage)) !== null && _a !== void 0 ? _a : \"\";\n    let decoded;\n    if (base64 === \"1\") {\n        decoded = protoBase64.dec(message);\n    }\n    else {\n        decoded = new TextEncoder().encode(message);\n    }\n    if (compression) {\n        decoded = await compression.decompress(decoded, readMaxBytes);\n    }\n    return decoded;\n}\nfunction parseUnaryMessage(method, useBinaryFormat, serialization, input) {\n    if (input instanceof Uint8Array) {\n        return serialization.getI(useBinaryFormat).parse(input);\n    }\n    if (useBinaryFormat) {\n        throw new ConnectError(\"received parsed JSON request body, but content-type indicates binary format\", Code.Internal);\n    }\n    try {\n        return method.I.fromJson(input);\n    }\n    catch (e) {\n        throw ConnectError.from(e, Code.InvalidArgument);\n    }\n}\nfunction createStreamHandler(opt, spec, serialization, endStreamSerialization) {\n    return async function handle(req) {\n        assertByteStreamRequest(req);\n        const type = parseContentType(req.header.get(headerContentType));\n        if (type == undefined || !type.stream) {\n            return uResponseUnsupportedMediaType;\n        }\n        if (req.method !== methodPost) {\n            return uResponseMethodNotAllowed;\n        }\n        const timeout = parseTimeout(req.header.get(headerTimeout), opt.maxTimeoutMs);\n        const context = createHandlerContext(Object.assign(Object.assign({}, spec), { requestMethod: req.method, protocolName, timeoutMs: timeout.timeoutMs, shutdownSignal: opt.shutdownSignal, requestSignal: req.signal, requestHeader: req.header, url: req.url, responseHeader: {\n                [headerContentType]: type.binary\n                    ? contentTypeStreamProto\n                    : contentTypeStreamJson,\n            }, contextValues: req.contextValues }));\n        const compression = compressionNegotiate(opt.acceptCompression, req.header.get(headerStreamEncoding), req.header.get(headerStreamAcceptEncoding), headerStreamAcceptEncoding);\n        if (compression.response) {\n            context.responseHeader.set(headerStreamEncoding, compression.response.name);\n        }\n        // We split the pipeline into two parts: The request iterator, and the\n        // response iterator. We do this because the request iterator is responsible\n        // for parsing the request body, and we don't want write errors of the response\n        // iterator to affect the request iterator.\n        const inputIt = pipe(req.body, transformPrepend(() => {\n            if (opt.requireConnectProtocolHeader) {\n                requireProtocolVersionHeader(req.header);\n            }\n            // raise compression error to serialize it as the end stream response\n            if (compression.error)\n                throw compression.error;\n            // raise timeout parsing error to serialize it as a trailer status\n            if (timeout.error)\n                throw timeout.error;\n            return undefined;\n        }), transformSplitEnvelope(opt.readMaxBytes), transformDecompressEnvelope(compression.request, opt.readMaxBytes), transformParseEnvelope(serialization.getI(type.binary), endStreamFlag));\n        const it = transformInvokeImplementation(spec, context, opt.interceptors)(inputIt)[Symbol.asyncIterator]();\n        const outputIt = pipe(\n        // We wrap the iterator in an async iterator to ensure that the\n        // abort signal is aborted when the iterator is done.\n        {\n            [Symbol.asyncIterator]() {\n                return {\n                    next: () => it.next(),\n                    throw: (e) => {\n                        var _a, _b;\n                        context.abort(e);\n                        return (_b = (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, e)) !== null && _b !== void 0 ? _b : Promise.reject({ done: true });\n                    },\n                    return: (v) => {\n                        var _a, _b;\n                        context.abort();\n                        return ((_b = (_a = it.return) === null || _a === void 0 ? void 0 : _a.call(it, v)) !== null && _b !== void 0 ? _b : Promise.resolve({ done: true, value: v }));\n                    },\n                };\n            },\n        }, transformSerializeEnvelope(serialization.getO(type.binary)), transformCatchFinally((e) => {\n            context.abort();\n            const end = {\n                metadata: context.responseTrailer,\n            };\n            if (e instanceof ConnectError) {\n                end.error = e;\n            }\n            else if (e !== undefined) {\n                end.error = new ConnectError(\"internal error\", Code.Internal, undefined, undefined, e);\n            }\n            return {\n                flags: endStreamFlag,\n                data: endStreamSerialization.serialize(end),\n            };\n        }), transformCompressEnvelope(compression.response, opt.compressMinBytes), transformJoinEnvelopes(), { propagateDownStreamError: true });\n        return Object.assign(Object.assign({}, uResponseOk), { \n            // We wait for the first response body bytes before resolving, so that\n            // implementations have a chance to add headers before an adapter commits\n            // them to the wire.\n            body: await untilFirst(outputIt), header: context.responseHeader });\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"./connect-error.js\";\nimport { Code } from \"./code.js\";\nimport { createMethodImplSpec, createServiceImplSpec, } from \"./implementation.js\";\nimport { createHandlerFactory as handlerFactoryGrpcWeb } from \"./protocol-grpc-web/handler-factory.js\";\nimport { createHandlerFactory as handlerFactoryGrpc } from \"./protocol-grpc/handler-factory.js\";\nimport { createHandlerFactory as handlerFactoryConnect } from \"./protocol-connect/handler-factory.js\";\nimport { createUniversalMethodHandler, createUniversalServiceHandlers, validateUniversalHandlerOptions, } from \"./protocol/universal-handler.js\";\n/**\n * Create a new ConnectRouter.\n */\nexport function createConnectRouter(routerOptions) {\n    const base = whichProtocols(routerOptions);\n    const handlers = [];\n    return {\n        handlers,\n        service(service, implementation, options) {\n            const { protocols } = whichProtocols(options, base);\n            handlers.push(...createUniversalServiceHandlers(createServiceImplSpec(service, implementation), protocols));\n            return this;\n        },\n        rpc(serviceOrMethod, methodOrImpl, implementationOrOptions, options) {\n            let service;\n            let method;\n            let impl;\n            let opt;\n            if (\"typeName\" in serviceOrMethod) {\n                service = serviceOrMethod;\n                method = methodOrImpl;\n                impl = implementationOrOptions;\n                opt = options;\n            }\n            else {\n                service = Object.assign(Object.assign({}, serviceOrMethod.service), { methods: {} });\n                method = serviceOrMethod;\n                impl = methodOrImpl;\n                opt = implementationOrOptions;\n            }\n            const { protocols } = whichProtocols(opt, base);\n            handlers.push(createUniversalMethodHandler(createMethodImplSpec(service, method, impl), protocols));\n            return this;\n        },\n    };\n}\nfunction whichProtocols(options, base) {\n    if (base && !options) {\n        return base;\n    }\n    const opt = base\n        ? Object.assign(Object.assign({}, validateUniversalHandlerOptions(base.options)), options) : Object.assign(Object.assign({}, options), validateUniversalHandlerOptions(options !== null && options !== void 0 ? options : {}));\n    const protocols = [];\n    if ((options === null || options === void 0 ? void 0 : options.grpc) !== false) {\n        protocols.push(handlerFactoryGrpc(opt));\n    }\n    if ((options === null || options === void 0 ? void 0 : options.grpcWeb) !== false) {\n        protocols.push(handlerFactoryGrpcWeb(opt));\n    }\n    if ((options === null || options === void 0 ? void 0 : options.connect) !== false) {\n        protocols.push(handlerFactoryConnect(opt));\n    }\n    if (protocols.length === 0) {\n        throw new ConnectError(\"cannot create handler, all protocols are disabled\", Code.InvalidArgument);\n    }\n    return {\n        options: opt,\n        protocols,\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport * as connect from \"./protocol-connect/headers.js\";\nimport * as grpc from \"./protocol-grpc/headers.js\";\nimport * as grpcWeb from \"./protocol-grpc-web/headers.js\";\n/**\n * CORS prevents rogue scripts in a web browser from making arbitrary requests\n * to other web servers.\n *\n * This object provides helpful constants to configure CORS middleware for\n * cross-domain requests with the protocols supported by Connect.\n *\n * Make sure to add application-specific headers that your application\n * uses as well.\n */\nexport const cors = {\n    /**\n     * Request methods that scripts running in the browser are permitted to use.\n     *\n     * To support cross-domain requests with the protocols supported by Connect,\n     * these headers fields must be included in the preflight response header\n     * Access-Control-Allow-Methods.\n     */\n    allowedMethods: [\"POST\", \"GET\"],\n    /**\n     * Header fields that scripts running in the browser are permitted to send.\n     *\n     * To support cross-domain requests with the protocols supported by Connect,\n     * these field names must be included in the preflight response header\n     * Access-Control-Allow-Headers.\n     *\n     * Make sure to include any application-specific headers your browser client\n     * may send.\n     */\n    allowedHeaders: [\n        connect.headerContentType,\n        connect.headerProtocolVersion,\n        connect.headerTimeout,\n        connect.headerStreamEncoding, // Unused in web browsers, but added for future-proofing\n        connect.headerStreamAcceptEncoding, // Unused in web browsers, but added for future-proofing\n        connect.headerUnaryEncoding, // Unused in web browsers, but added for future-proofing\n        connect.headerUnaryAcceptEncoding, // Unused in web browsers, but added for future-proofing\n        grpc.headerMessageType, // Unused in web browsers, but added for future-proofing\n        grpcWeb.headerXGrpcWeb,\n        grpcWeb.headerXUserAgent,\n        grpcWeb.headerTimeout,\n    ],\n    /**\n     * Header fields that scripts running the browser are permitted to see.\n     *\n     * To support cross-domain requests with the protocols supported by Connect,\n     * these field names must be included in header Access-Control-Expose-Headers\n     * of the actual response.\n     *\n     * Make sure to include any application-specific headers your browser client\n     * should see. If your application uses trailers, they will be sent as header\n     * fields with a `Trailer-` prefix for Connect unary RPCs - make sure to\n     * expose them as well if you want them to be visible in all supported\n     * protocols.\n     */\n    exposedHeaders: [\n        grpcWeb.headerGrpcStatus, // Crucial for gRPC-web\n        grpcWeb.headerGrpcMessage, // Crucial for gRPC-web\n        grpcWeb.headerStatusDetailsBin, // Error details in gRPC, gRPC-web\n        connect.headerUnaryEncoding, // Unused in web browsers, but added for future-proofing\n        connect.headerStreamEncoding, // Unused in web browsers, but added for future-proofing\n    ],\n};\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { MethodKind } from \"@bufbuild/protobuf\";\nimport { headerContentType, headerStreamAcceptEncoding, headerStreamEncoding, headerUnaryAcceptEncoding, headerUnaryEncoding, headerTimeout, headerProtocolVersion, headerUserAgent, } from \"./headers.js\";\nimport { protocolVersion } from \"./version.js\";\nimport { contentTypeStreamJson, contentTypeStreamProto, contentTypeUnaryJson, contentTypeUnaryProto, } from \"./content-type.js\";\n/**\n * Creates headers for a Connect request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    if (timeoutMs !== undefined) {\n        result.set(headerTimeout, `${timeoutMs}`);\n    }\n    result.set(headerContentType, methodKind == MethodKind.Unary\n        ? useBinaryFormat\n            ? contentTypeUnaryProto\n            : contentTypeUnaryJson\n        : useBinaryFormat\n            ? contentTypeStreamProto\n            : contentTypeStreamJson);\n    result.set(headerProtocolVersion, protocolVersion);\n    if (setUserAgent) {\n        result.set(headerUserAgent, \"connect-es/1.6.1\");\n    }\n    return result;\n}\n/**\n * Creates headers for a Connect request with compression.\n *\n * Note that we always set the Content-Encoding header for unary methods.\n * It is up to the caller to decide whether to apply compression - and remove\n * the header if compression is not used, for example because the payload is\n * too small to make compression effective.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeaderWithCompression(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression, setUserAgent) {\n    const result = requestHeader(methodKind, useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent);\n    if (sendCompression != null) {\n        const name = methodKind == MethodKind.Unary\n            ? headerUnaryEncoding\n            : headerStreamEncoding;\n        result.set(name, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        const name = methodKind == MethodKind.Unary\n            ? headerUnaryAcceptEncoding\n            : headerStreamAcceptEncoding;\n        result.set(name, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { MethodKind } from \"@bufbuild/protobuf\";\nimport { Code } from \"../code.js\";\nimport { codeFromHttpStatus } from \"./http-status.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { parseContentType } from \"./content-type.js\";\nimport { headerContentType, headerStreamEncoding, headerUnaryEncoding, } from \"./headers.js\";\n/**\n * Validates response status and header for the Connect protocol.\n * Throws a ConnectError if the header indicates an error, or if\n * the content type is unexpected, with the following exception:\n * For unary RPCs with an HTTP error status, this returns an error\n * derived from the HTTP status instead of throwing it, giving an\n * implementation a chance to parse a Connect error from the wire.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateResponse(methodKind, useBinaryFormat, status, headers) {\n    const mimeType = headers.get(headerContentType);\n    const parsedType = parseContentType(mimeType);\n    if (status !== 200) {\n        const errorFromStatus = new ConnectError(`HTTP ${status}`, codeFromHttpStatus(status), headers);\n        // If parsedType is defined and it is not binary, then this is a unary JSON response\n        if (methodKind == MethodKind.Unary && parsedType && !parsedType.binary) {\n            return { isUnaryError: true, unaryError: errorFromStatus };\n        }\n        throw errorFromStatus;\n    }\n    const allowedContentType = {\n        binary: useBinaryFormat,\n        stream: methodKind !== MethodKind.Unary,\n    };\n    if ((parsedType === null || parsedType === void 0 ? void 0 : parsedType.binary) !== allowedContentType.binary ||\n        parsedType.stream !== allowedContentType.stream) {\n        throw new ConnectError(`unsupported content type ${mimeType}`, parsedType === undefined ? Code.Unknown : Code.Internal, headers);\n    }\n    return { isUnaryError: false };\n}\n/**\n * Validates response status and header for the Connect protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * @private\n */\nexport function validateResponseWithCompression(methodKind, acceptCompression, useBinaryFormat, status, headers) {\n    let compression;\n    const encoding = headers.get(methodKind == MethodKind.Unary ? headerUnaryEncoding : headerStreamEncoding);\n    if (encoding != null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new ConnectError(`unsupported response encoding \"${encoding}\"`, Code.Internal, headers);\n        }\n    }\n    return Object.assign({ compression }, validateResponse(methodKind, useBinaryFormat, status, headers));\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Message, protoBase64 } from \"@bufbuild/protobuf\";\nimport { headerContentType, headerProtocolVersion, headerUnaryAcceptEncoding, headerUnaryContentLength, headerUnaryEncoding, } from \"./headers.js\";\nimport { protocolVersion } from \"./version.js\";\nconst contentTypePrefix = \"application/\";\nfunction encodeMessageForUrl(message, useBase64) {\n    if (useBase64) {\n        // TODO(jchadwick-buf): Three regex replaces seems excessive.\n        // Can we make protoBase64.enc more flexible?\n        return protoBase64\n            .enc(message)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\")\n            .replace(/=+$/, \"\");\n    }\n    else {\n        return encodeURIComponent(new TextDecoder().decode(message));\n    }\n}\n/**\n * @private Internal code, does not follow semantic versioning.\n */\nexport function transformConnectPostToGetRequest(request, message, useBase64) {\n    let query = `?connect=v${protocolVersion}`;\n    const contentType = request.header.get(headerContentType);\n    if ((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(contentTypePrefix)) === 0) {\n        query +=\n            \"&encoding=\" +\n                encodeURIComponent(contentType.slice(contentTypePrefix.length));\n    }\n    const compression = request.header.get(headerUnaryEncoding);\n    if (compression !== null && compression !== \"identity\") {\n        query += \"&compression=\" + encodeURIComponent(compression);\n        // Force base64 for compressed payloads.\n        useBase64 = true;\n    }\n    if (useBase64) {\n        query += \"&base64=1\";\n    }\n    query += \"&message=\" + encodeMessageForUrl(message, useBase64);\n    const url = request.url + query;\n    // Omit headers that are not used for unary GET requests.\n    const header = new Headers(request.header);\n    [\n        headerProtocolVersion,\n        headerContentType,\n        headerUnaryContentLength,\n        headerUnaryEncoding,\n        headerUnaryAcceptEncoding,\n    ].forEach((h) => header.delete(h));\n    return Object.assign(Object.assign({}, request), { init: Object.assign(Object.assign({}, request.init), { method: \"GET\" }), url,\n        header });\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { applyInterceptors } from \"../interceptor.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { createDeadlineSignal, createLinkedAbortController, getAbortSignalReason, } from \"./signals.js\";\nimport { normalize, normalizeIterable } from \"./normalize.js\";\n/**\n * Runs a unary method with the given interceptors. Note that this function\n * is only used when implementing a Transport.\n */\nexport function runUnaryCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: normalize(opt.req.method.I, opt.req.message), signal });\n    return next(req).then((res) => {\n        done();\n        return res;\n    }, abort);\n}\n/**\n * Runs a server-streaming method with the given interceptors. Note that this\n * function is only used when implementing a Transport.\n */\nexport function runStreamingCall(opt) {\n    const next = applyInterceptors(opt.next, opt.interceptors);\n    const [signal, abort, done] = setupSignal(opt);\n    const req = Object.assign(Object.assign({}, opt.req), { message: normalizeIterable(opt.req.method.I, opt.req.message), signal });\n    let doneCalled = false;\n    // Call return on the request iterable to indicate\n    // that we will no longer consume it and it should\n    // cleanup any allocated resources.\n    signal.addEventListener(\"abort\", function () {\n        var _a, _b;\n        const it = opt.req.message[Symbol.asyncIterator]();\n        // If the signal is aborted due to an error, we want to throw\n        // the error to the request iterator.\n        if (!doneCalled) {\n            (_a = it.throw) === null || _a === void 0 ? void 0 : _a.call(it, this.reason).catch(() => {\n                // throw returns a promise, which we don't care about.\n                //\n                // Uncaught promises are thrown at sometime/somewhere by the event loop,\n                // this is to ensure error is caught and ignored.\n            });\n        }\n        (_b = it.return) === null || _b === void 0 ? void 0 : _b.call(it).catch(() => {\n            // return returns a promise, which we don't care about.\n            //\n            // Uncaught promises are thrown at sometime/somewhere by the event loop,\n            // this is to ensure error is caught and ignored.\n        });\n    });\n    return next(req).then((res) => {\n        return Object.assign(Object.assign({}, res), { message: {\n                [Symbol.asyncIterator]() {\n                    const it = res.message[Symbol.asyncIterator]();\n                    return {\n                        next() {\n                            return it.next().then((r) => {\n                                if (r.done == true) {\n                                    doneCalled = true;\n                                    done();\n                                }\n                                return r;\n                            }, abort);\n                        },\n                        // We deliberately omit throw/return.\n                    };\n                },\n            } });\n    }, abort);\n}\n/**\n * Create an AbortSignal for Transport implementations. The signal is available\n * in UnaryRequest and StreamingRequest, and is triggered when the call is\n * aborted (via a timeout or explicit cancellation), errored (e.g. when reading\n * an error from the server from the wire), or finished successfully.\n *\n * Transport implementations can pass the signal to HTTP clients to ensure that\n * there are no unused connections leak.\n *\n * Returns a tuple:\n * [0]: The signal, which is also aborted if the optional deadline is reached.\n * [1]: Function to call if the Transport encountered an error.\n * [2]: Function to call if the Transport finished without an error.\n */\nfunction setupSignal(opt) {\n    const { signal, cleanup } = createDeadlineSignal(opt.timeoutMs);\n    const controller = createLinkedAbortController(opt.signal, signal);\n    return [\n        controller.signal,\n        function abort(reason) {\n            // We peek at the deadline signal because fetch() will throw an error on\n            // abort that discards the signal reason.\n            const e = ConnectError.from(signal.aborted ? getAbortSignalReason(signal) : reason);\n            controller.abort(e);\n            cleanup();\n            return Promise.reject(e);\n        },\n        function done() {\n            cleanup();\n            controller.abort();\n        },\n    ];\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { MethodIdempotency } from \"@bufbuild/protobuf\";\nimport { requestHeaderWithCompression } from \"./request-header.js\";\nimport { headerUnaryContentLength, headerUnaryEncoding } from \"./headers.js\";\nimport { validateResponseWithCompression } from \"./validate-response.js\";\nimport { trailerDemux } from \"./trailer-mux.js\";\nimport { errorFromJsonBytes } from \"./error-json.js\";\nimport { createEndStreamSerialization, endStreamFlag } from \"./end-stream.js\";\nimport { transformConnectPostToGetRequest } from \"./get-request.js\";\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { appendHeaders } from \"../http-headers.js\";\nimport { createAsyncIterable, pipeTo, sinkAllBytes, pipe, transformSerializeEnvelope, transformCompressEnvelope, transformJoinEnvelopes, transformSplitEnvelope, transformDecompressEnvelope, transformParseEnvelope, } from \"../protocol/async-iterable.js\";\nimport { createMethodUrl } from \"../protocol/create-method-url.js\";\nimport { runUnaryCall, runStreamingCall } from \"../protocol/run-call.js\";\nimport { createMethodSerializationLookup } from \"../protocol/serialization.js\";\nimport { createContextValues } from \"../context-values.js\";\n/**\n * Create a Transport for the Connect protocol.\n */\nexport function createTransport(opt) {\n    return {\n        async unary(service, method, signal, timeoutMs, header, message, contextValues) {\n            const serialization = createMethodSerializationLookup(method, opt.binaryOptions, opt.jsonOptions, opt);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? opt.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return await runUnaryCall({\n                interceptors: opt.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: createMethodUrl(opt.baseUrl, service, method),\n                    init: {},\n                    header: requestHeaderWithCompression(method.kind, opt.useBinaryFormat, timeoutMs, header, opt.acceptCompression, opt.sendCompression, true),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    let requestBody = serialization\n                        .getI(opt.useBinaryFormat)\n                        .serialize(req.message);\n                    if (opt.sendCompression &&\n                        requestBody.byteLength > opt.compressMinBytes) {\n                        requestBody = await opt.sendCompression.compress(requestBody);\n                        req.header.set(headerUnaryEncoding, opt.sendCompression.name);\n                    }\n                    else {\n                        req.header.delete(headerUnaryEncoding);\n                    }\n                    const useGet = opt.useHttpGet === true &&\n                        method.idempotency === MethodIdempotency.NoSideEffects;\n                    let body;\n                    if (useGet) {\n                        req = transformConnectPostToGetRequest(req, requestBody, opt.useBinaryFormat);\n                    }\n                    else {\n                        body = createAsyncIterable([requestBody]);\n                    }\n                    const universalResponse = await opt.httpClient({\n                        url: req.url,\n                        method: (_a = req.init.method) !== null && _a !== void 0 ? _a : \"POST\",\n                        header: req.header,\n                        signal: req.signal,\n                        body,\n                    });\n                    const { compression, isUnaryError, unaryError } = validateResponseWithCompression(method.kind, opt.acceptCompression, opt.useBinaryFormat, universalResponse.status, universalResponse.header);\n                    const [header, trailer] = trailerDemux(universalResponse.header);\n                    let responseBody = await pipeTo(universalResponse.body, sinkAllBytes(opt.readMaxBytes, universalResponse.header.get(headerUnaryContentLength)), { propagateDownStreamError: false });\n                    if (compression) {\n                        responseBody = await compression.decompress(responseBody, opt.readMaxBytes);\n                    }\n                    if (isUnaryError) {\n                        throw errorFromJsonBytes(responseBody, appendHeaders(header, trailer), unaryError);\n                    }\n                    return {\n                        stream: false,\n                        service,\n                        method,\n                        header,\n                        message: serialization\n                            .getO(opt.useBinaryFormat)\n                            .parse(responseBody),\n                        trailer,\n                    };\n                },\n            });\n        },\n        async stream(service, method, signal, timeoutMs, header, input, contextValues) {\n            const serialization = createMethodSerializationLookup(method, opt.binaryOptions, opt.jsonOptions, opt);\n            const endStreamSerialization = createEndStreamSerialization(opt.jsonOptions);\n            timeoutMs =\n                timeoutMs === undefined\n                    ? opt.defaultTimeoutMs\n                    : timeoutMs <= 0\n                        ? undefined\n                        : timeoutMs;\n            return runStreamingCall({\n                interceptors: opt.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: createMethodUrl(opt.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeaderWithCompression(method.kind, opt.useBinaryFormat, timeoutMs, header, opt.acceptCompression, opt.sendCompression, true),\n                    contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),\n                    message: input,\n                },\n                next: async (req) => {\n                    const uRes = await opt.httpClient({\n                        url: req.url,\n                        method: \"POST\",\n                        header: req.header,\n                        signal: req.signal,\n                        body: pipe(req.message, transformSerializeEnvelope(serialization.getI(opt.useBinaryFormat)), transformCompressEnvelope(opt.sendCompression, opt.compressMinBytes), transformJoinEnvelopes(), { propagateDownStreamError: true }),\n                    });\n                    const { compression } = validateResponseWithCompression(method.kind, opt.acceptCompression, opt.useBinaryFormat, uRes.status, uRes.header);\n                    const res = Object.assign(Object.assign({}, req), { header: uRes.header, trailer: new Headers(), message: pipe(uRes.body, transformSplitEnvelope(opt.readMaxBytes), transformDecompressEnvelope(compression !== null && compression !== void 0 ? compression : null, opt.readMaxBytes), transformParseEnvelope(serialization.getO(opt.useBinaryFormat), endStreamFlag, endStreamSerialization), function (iterable) {\n                            return __asyncGenerator(this, arguments, function* () {\n                                var _a, e_1, _b, _c;\n                                let endStreamReceived = false;\n                                try {\n                                    for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {\n                                        _c = iterable_1_1.value;\n                                        _d = false;\n                                        const chunk = _c;\n                                        if (chunk.end) {\n                                            if (endStreamReceived) {\n                                                throw new ConnectError(\"protocol error: received extra EndStreamResponse\", Code.InvalidArgument);\n                                            }\n                                            endStreamReceived = true;\n                                            if (chunk.value.error) {\n                                                const error = chunk.value.error;\n                                                uRes.header.forEach((value, key) => {\n                                                    error.metadata.append(key, value);\n                                                });\n                                                throw error;\n                                            }\n                                            chunk.value.metadata.forEach((value, key) => res.trailer.set(key, value));\n                                            continue;\n                                        }\n                                        if (endStreamReceived) {\n                                            throw new ConnectError(\"protocol error: received extra message after EndStreamResponse\", Code.InvalidArgument);\n                                        }\n                                        yield yield __await(chunk.value);\n                                    }\n                                }\n                                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                finally {\n                                    try {\n                                        if (!_d && !_a && (_b = iterable_1.return)) yield __await(_b.call(iterable_1));\n                                    }\n                                    finally { if (e_1) throw e_1.error; }\n                                }\n                                if (!endStreamReceived) {\n                                    throw new ConnectError(\"protocol error: missing EndStreamResponse\", Code.InvalidArgument);\n                                }\n                            });\n                        }, { propagateDownStreamError: true }) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\nimport { ConnectError } from \"../connect-error.js\";\nimport { createAsyncIterable, pipe } from \"./async-iterable.js\";\nimport { getAbortSignalReason } from \"./signals.js\";\n/**\n * An in-memory UniversalClientFn that can be used to route requests to a ConnectRouter\n * bypassing network calls. Useful for testing and calling in-process services.\n */\nexport function createUniversalHandlerClient(uHandlers) {\n    const handlerMap = new Map();\n    for (const handler of uHandlers) {\n        handlerMap.set(handler.requestPath, handler);\n    }\n    return async (uClientReq) => {\n        var _a, _b, _c;\n        const pathname = new URL(uClientReq.url).pathname;\n        const handler = handlerMap.get(pathname);\n        if (!handler) {\n            throw new ConnectError(`RouterHttpClient: no handler registered for ${pathname}`, Code.Unimplemented);\n        }\n        const reqSignal = (_a = uClientReq.signal) !== null && _a !== void 0 ? _a : new AbortController().signal;\n        const uServerRes = await raceSignal(reqSignal, handler({\n            body: (_b = uClientReq.body) !== null && _b !== void 0 ? _b : createAsyncIterable([]),\n            httpVersion: \"2.0\",\n            method: uClientReq.method,\n            url: uClientReq.url,\n            header: uClientReq.header,\n            signal: reqSignal,\n        }));\n        const body = (_c = uServerRes.body) !== null && _c !== void 0 ? _c : createAsyncIterable([]);\n        return {\n            body: pipe(body, (iterable) => {\n                return {\n                    [Symbol.asyncIterator]() {\n                        const it = iterable[Symbol.asyncIterator]();\n                        const w = {\n                            next() {\n                                return raceSignal(reqSignal, it.next());\n                            },\n                        };\n                        if (it.throw !== undefined) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- can't handle mutated object sensibly\n                            w.throw = (e) => it.throw(e);\n                        }\n                        if (it.return !== undefined) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion,@typescript-eslint/no-explicit-any -- can't handle mutated object sensibly\n                            w.return = (value) => it.return(value);\n                        }\n                        return w;\n                    },\n                };\n            }),\n            header: new Headers(uServerRes.header),\n            status: uServerRes.status,\n            trailer: new Headers(uServerRes.trailer),\n        };\n    };\n}\n/**\n * Wrap a promise, and reject early if the given signal triggers before the\n * promise is settled.\n */\nfunction raceSignal(signal, promise) {\n    let cleanup;\n    const signalPromise = new Promise((_, reject) => {\n        const onAbort = () => reject(getAbortSignalReason(signal));\n        if (signal.aborted) {\n            return onAbort();\n        }\n        signal.addEventListener(\"abort\", onAbort);\n        cleanup = () => signal.removeEventListener(\"abort\", onAbort);\n    });\n    return Promise.race([signalPromise, promise]).finally(cleanup);\n}\n", "// Copyright 2021-2024 The Connect Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { createTransport } from \"./protocol-connect/transport.js\";\nimport { createUniversalHandlerClient } from \"./protocol/universal-handler-client.js\";\nimport { createConnectRouter } from \"./router.js\";\n/**\n * Creates a Transport that routes requests to the configured router. Useful for testing\n * and calling services running in the same process.\n *\n * This can be used to test both client logic by using this to stub/mock the backend,\n * and to test server logic by using this to run without needing to spin up a server.\n */\nexport function createRouterTransport(routes, options) {\n    var _a, _b;\n    const router = createConnectRouter(Object.assign(Object.assign({}, ((_a = options === null || options === void 0 ? void 0 : options.router) !== null && _a !== void 0 ? _a : {})), { connect: true }));\n    routes(router);\n    return createTransport(Object.assign({ httpClient: createUniversalHandlerClient(router.handlers), baseUrl: \"https://in-memory\", useBinaryFormat: true, interceptors: [], acceptCompression: [], sendCompression: null, compressMinBytes: Number.MAX_SAFE_INTEGER, readMaxBytes: Number.MAX_SAFE_INTEGER, writeMaxBytes: Number.MAX_SAFE_INTEGER }, ((_b = options === null || options === void 0 ? void 0 : options.transport) !== null && _b !== void 0 ? _b : {})));\n}\n"],
  "mappings": "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",
  "names": ["Code", "value", "v", "endStreamFlag", "offset", "__asyncValues", "v", "__asyncValues", "v", "__await", "__asyncDelegator", "__asyncGenerator", "createUnaryFn", "createServerStreamingFn", "__await", "__asyncGenerator", "__asyncValues", "v", "__asyncDelegator", "contentTypeRegExp", "contentTypeProto", "contentTypeJson", "parseContentType", "protocolName", "methodPost", "createHandlerFactory", "createHandler", "contentTypeRegExp", "parseContentType", "contentTypeProto", "contentTypeJson", "contentTypeRegExp", "parseContentType", "headerContentType", "headerTimeout", "headerUserAgent", "parseTimeout", "requestHeader", "protocolName", "methodPost", "createHandlerFactory", "contentTypeRegExp", "parseContentType", "headerContentType", "parseTimeout", "headerTimeout", "createHandlerFactory", "headerContentType", "headerTimeout", "headerTimeout", "headerContentType", "headerUserAgent", "headerContentType", "parseContentType", "headerContentType", "__asyncValues", "v", "__await", "__asyncGenerator", "header"]
}
